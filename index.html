<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indicadores de Liquidación</title>
    <!-- Tailwind CSS con precarga -->
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Iconos -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <style>
        .filter-select {
            border: 1px solid #D1D5DB;
            border-radius: 0.375rem;
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            outline: none;
            color: #374151;
            font-weight: 500;
        }
        .filter-select:focus {
            box-shadow: 0 0 0 4px rgba(59,130,246,0.08);
            border-color: #3B82F6;
        }
        .loader-overlay {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(2px);
        }
        /* Optimización de renderizado */
        canvas {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            /* Garantizar que los contenedores de los charts mantengan tamaño
               antes de que Chart.js los inicialice para evitar saltos de layout */
            min-height: 220px !important;
        }
        /* Indicador de estado */
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 8px;
        }
        .status-success { background-color: #10b981; }
        .status-loading { background-color: #f59e0b; animation: pulse 2s infinite; }
        .status-error { background-color: #ef4444; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        /* Estilos para tabs */
        .tab-button {
            padding: 0.375rem 0.75rem;
            font-size: 0.8rem;
            font-weight: 500;
            border-radius: 0.5rem;
            transition: all 0.2s ease;
            background-color: #f3f4f6;
            color: #4b5563;
            border: none;
            cursor: pointer;
            white-space: nowrap;
        }
        .tab-button:hover {
            background-color: #e5e7eb;
        }
        .tab-button.active {
            background-color: #2563eb;
            color: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        /* Estilo específico para botón Pds no reportadas */
        #tabPdsRegularizar {
            padding: 0.75rem 0.5rem;
            height: auto;
            min-height: 3.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
            max-width: 110px;
            text-align: center;
            white-space: normal;
        }
        #tabPdsRegularizar i {
            margin-right: 0.3rem;
            display: inline;
        }
        /* Estilo específico para botón Saldo 1ra x Cliente */
        #tabSaldo1raCliente {
            padding: 0.75rem 0.5rem;
            height: auto;
            min-height: 3.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
            max-width: 110px;
            text-align: center;
            white-space: normal;
        }
        #tabSaldo1raCliente i {
            margin-right: 0.3rem;
            display: inline;
        }
        /* Estilo específico para botón Saldo 2da x Cliente */
        #tabSaldo2daCliente {
            padding: 0.75rem 0.5rem;
            height: auto;
            min-height: 3.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
            max-width: 110px;
            text-align: center;
            white-space: normal;
        }
        #tabSaldo2daCliente i {
            margin-right: 0.3rem;
            display: inline;
        }
        /* Estilo específico para botón Saldo 3ra x Cliente */
        #tabSaldo3raCliente {
            padding: 0.75rem 0.5rem;
            height: auto;
            min-height: 3.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
            max-width: 110px;
            text-align: center;
            white-space: normal;
        }
        #tabSaldo3raCliente i {
            margin-right: 0.3rem;
            display: inline;
        }
        /* Estilo para botones Saldos y HOD */
        #tabSaldos, #tabHOD {
            padding: 0.75rem 0.5rem;
            height: auto;
            min-height: 3.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tab-content {
            display: none !important;
        }
        .tab-content.active {
            display: flex !important;
        }
    </style>
</head>
<body class="bg-slate-100 h-screen w-screen overflow-hidden flex flex-col p-4 font-sans relative">

    <!-- Loader General -->
    <div id="mainLoader" class="loader-overlay absolute inset-0 z-50 flex flex-col items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl p-6 flex flex-col items-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mb-3"></div>
            <p id="loaderText" class="text-blue-600 font-bold">Cargando datos...</p>
            <p class="text-gray-500 text-sm mt-1">Por favor espera</p>
        </div>
    </div>

    <!-- BLOQUE SUPERIOR: Título y Filtros -->
    <div class="bg-white rounded-xl shadow-sm px-3 py-2 mb-3 flex flex-col md:flex-row justify-between items-center gap-2 shrink-0">
        <div class="flex items-center gap-2">
            <div class="flex items-center gap-2">
                <div class="bg-blue-600 text-white p-1.5 rounded-lg">
                    <i class="fa-solid fa-chart-line text-lg"></i>
                </div>
                <div>
                    <h1 class="text-xl font-bold text-gray-800 tracking-tight">Indicadores de Liquidación</h1>
                    <div id="connectionStatus" class="text-xs text-gray-500 flex items-center">
                        <span>Estado: </span>
                        <span id="statusText" class="ml-1 font-medium">Listo</span>
                        <span id="statusDot" class="status-indicator status-success"></span>
                    </div>
                </div>
            </div>
            <!-- Tabs de navegación -->
            <div class="flex items-center gap-1.5 ml-3 border-l pl-3 border-gray-300">
                <button id="tabPdsRegularizar" class="tab-button active" onclick="switchTab('pdsRegularizar')">
                    <i class="fa-solid fa-chart-column mr-1"></i>Pds no<br>reportadas
                </button>
                <button id="tabSaldos" class="tab-button" onclick="switchTab('saldos')">
                    <i class="fa-solid fa-layer-group mr-1"></i>Saldos
                </button>
                <button id="tabSaldo1raCliente" class="tab-button" onclick="switchTab('saldo1raCliente')">
                    <i class="fa-solid fa-users mr-1"></i>Saldo 1ra<br>x Cliente
                </button>
                <button id="tabSaldo2daCliente" class="tab-button" onclick="switchTab('saldo2daCliente')">
                    <i class="fa-solid fa-users mr-1"></i>Saldo 2da<br>x Cliente
                </button>
                <button id="tabSaldo3raCliente" class="tab-button" onclick="switchTab('saldo3raCliente')">
                    <i class="fa-solid fa-users mr-1"></i>Saldo 3ra<br>x Cliente
                </button>
                <button id="tabHOD" class="tab-button relative" onclick="switchTab('hod')" title="HOD">
                    <i class="fa-solid fa-plane mr-1"></i>
                    <span class="absolute top-0 right-0 h-2 w-2 bg-blue-600 rounded-full"></span>
                </button>
            </div>
        </div>

        <div class="flex flex-wrap items-center gap-2 bg-gray-50 p-1.5 rounded-lg border border-gray-100">
            <div class="flex items-center gap-1.5">
                <span class="text-xs font-bold text-gray-500 uppercase tracking-wide">Desde:</span>
                <select id="desdeAnio" class="filter-select bg-white">
                    <option value="2024">2024</option>
                    <option value="2025">2025</option>
                    <option value="2026">2026</option>
                </select>
                <select id="desdeMes" class="filter-select bg-white">
                    <option value="0">Ene</option><option value="1">Feb</option><option value="2">Mar</option>
                    <option value="3">Abr</option><option value="4">May</option><option value="5">Jun</option>
                    <option value="6">Jul</option><option value="7">Ago</option><option value="8">Set</option>
                    <option value="9">Oct</option><option value="10">Nov</option><option value="11">Dic</option>
                </select>
            </div>
            <div class="h-5 w-px bg-gray-300 mx-0.5"></div>
            <div class="flex items-center gap-1.5">
                <span class="text-xs font-bold text-gray-500 uppercase tracking-wide">Hasta:</span>
                <select id="hastaAnio" class="filter-select bg-white">
                    <option value="2024">2024</option>
                    <option value="2025">2025</option>
                    <option value="2026">2026</option>
                </select>
                <select id="hastaMes" class="filter-select bg-white">
                    <option value="0">Ene</option><option value="1">Feb</option><option value="2">Mar</option>
                    <option value="3">Abr</option><option value="4">May</option><option value="5">Jun</option>
                    <option value="6">Jul</option><option value="7">Ago</option><option value="8">Set</option>
                    <option value="9">Oct</option><option value="10">Nov</option><option value="11">Dic</option>
                </select>
            </div>
            
            <!-- Botón circular para cargar datos -->
            <div class="ml-1">
                <a href="importar_excel.html" title="Cargar datos" class="inline-flex items-center justify-center h-8 w-8 rounded-full bg-blue-600 hover:bg-blue-700 text-white shadow-md text-sm">
                    <i class="fa-solid fa-file-import"></i>
                </a>
            </div>
        </div>
    </div>

    <!-- BLOQUE INFERIOR: Contenido con Tabs -->
    
    <!-- Tab 1: Pds no reportadas -->
    <div id="contentPdsRegularizar" class="tab-content active flex-1 flex flex-col gap-1 min-h-0">
        <!-- Gráfico 1: Ingreso Neto vs %Diferencia -->
        <div class="bg-white rounded-xl shadow-sm p-4 border border-gray-200 flex flex-col relative min-h-0" style="flex: 0 0 60%;">
            <div class="flex items-start justify-between mb-2">
                <div class="flex items-center gap-2">
                    <button id="btnModalClienteChart" title="Ver por Cliente" class="inline-flex items-center justify-center h-8 w-8 rounded-full bg-blue-100 hover:bg-blue-200 text-blue-600 shadow-sm transition-all">
                        <i class="fa-solid fa-user"></i>
                    </button>
                    <h3 id="chart1Title" class="text-gray-600 font-bold">Ingreso Neto vs No reportadas</h3>
                </div>
                <div id="chart1Legend" class="flex items-center gap-4"></div>
            </div>
            <div class="flex-1 w-full min-h-0 relative"><canvas id="chart1" style="width:100% !important; height:100% !important; display:block;"></canvas></div>
        </div>
            <!-- Bloque Acciones: tabla tomada desde la hoja 'acciones' filtrada por columna 'Pestaña' -->
            <div id="accionesBlock" class="bg-white rounded-xl shadow-sm p-4 border border-gray-200 mt-1 flex flex-col min-h-0" style="flex: 0 0 40.5%;">
                <div class="flex items-center justify-between mb-2">
                <h3 class="text-gray-600 font-bold">Acciones</h3>
                <div id="accionesFilterInfo" class="text-xs text-gray-500"></div>
            </div>
                <div class="overflow-auto h-full">
                    <table id="tablaAcciones" class="w-full text-sm">
                        <thead id="tablaAccionesHead" class="bg-gray-800 sticky top-0 text-white text-xs font-bold"></thead>
                        <tbody id="tablaAccionesBody" class="text-gray-700">
                            <tr><td colspan="4" class="py-2 text-center text-gray-400">Cargando...</td></tr>
                        </tbody>
                    </table>
                    <div id="accionesColWidths" class="text-xs text-gray-500 mt-2"></div>
                </div>
            </div>
    </div>

    <!-- Tab 2: Saldos -->
    <div id="contentSaldos" class="tab-content flex-1 flex flex-row gap-4 min-h-0 overflow-hidden">
        <!-- Bloque 1: Saldos 1ra -->
        <div class="bg-white rounded-xl shadow-sm p-4 border border-gray-200 flex flex-col relative min-h-0" style="flex: 1 1 33%;">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-gray-700 font-bold text-base flex items-center gap-2">
                    <span class="inline-flex items-center justify-center w-7 h-7 rounded-full bg-blue-100 text-blue-600 text-sm font-bold">1</span>
                    Saldos 1ra
                </h3>
            </div>
            <div class="flex-1 w-full min-h-0 relative">
                <canvas id="chart5" style="width:100% !important; height:100% !important; display:block;"></canvas>
            </div>
        </div>
        
        <!-- Bloque 2: Saldos 2da -->
        <div class="bg-white rounded-xl shadow-sm p-4 border border-gray-200 flex flex-col relative min-h-0" style="flex: 1 1 33%;">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-gray-700 font-bold text-base flex items-center gap-2">
                    <span class="inline-flex items-center justify-center w-7 h-7 rounded-full bg-amber-100 text-amber-600 text-sm font-bold">2</span>
                    Saldos 2da
                </h3>
            </div>
            <div class="flex-1 w-full min-h-0 relative">
                <canvas id="chart2" style="width:100% !important; height:100% !important; display:block;"></canvas>
            </div>
        </div>
        
        <!-- Bloque 3: Saldos 3ra -->
        <div class="bg-white rounded-xl shadow-sm p-4 border border-gray-200 flex flex-col relative min-h-0" style="flex: 1 1 33%;">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-gray-700 font-bold text-base flex items-center gap-2">
                    <span class="inline-flex items-center justify-center w-7 h-7 rounded-full bg-red-100 text-red-600 text-sm font-bold">3</span>
                    Saldos 3ra
                </h3>
            </div>
            <div class="flex-1 w-full min-h-0 relative">
                <canvas id="chart3" style="width:100% !important; height:100% !important; display:block;"></canvas>
            </div>
        </div>
    </div>

    <!-- Tab 3: Saldo 1ra x Cliente -->
    <div id="contentSaldo1raCliente" class="tab-content flex-1 flex flex-col gap-4 min-h-0">
        <!-- Detalle por Cliente de Saldos 1ra: Tabla + Gráfico -->
        <div class="bg-white rounded-xl shadow-sm p-4 border border-gray-200 flex flex-col relative gap-2">
            <div class="flex items-center justify-between mb-0">
                <h3 class="text-gray-600 font-bold">Detalle por Cliente de Saldos 1ra</h3>
                <span id="clientePeriodo" class="text-lg text-gray-700 font-bold"></span>
            </div>
            
            <!-- Contenedor flex para tabla y gráfico lado a lado -->
            <div class="flex-1 flex flex-col md:flex-row gap-4 min-h-0">
                <!-- Tabla de clientes (50% ancho en desktop) -->
                <div class="w-full md:w-1/2 overflow-auto min-h-0 max-h-full">
                    <table id="tablaClientes" class="w-full text-sm">
                        <thead class="bg-gray-800 sticky top-0">
                            <tr class="text-left text-xs font-bold text-white">
                                <th class="py-2 px-2 border-b">Cliente</th>
                                <th class="py-2 px-2 border-b">Tipo</th>
                                <th class="py-2 px-2 border-b text-right">Prendas Pedido</th>
                                <th class="py-2 px-2 border-b text-right">Prendas Ingreso Neto</th>
                                <th class="py-2 px-2 border-b text-right">Saldos 1ra</th>
                                <th class="py-2 px-2 border-b text-right">%Saldo 1ra</th>
                            </tr>
                        </thead>
                        <tbody id="tablaClientesBody" class="text-gray-700">
                            <tr><td colspan="6" class="py-2 text-center text-gray-400">Cargando...</td></tr>
                        </tbody>
                    </table>
                </div>

                <!-- Gráfico de clientes (50% ancho en desktop) -->
                <div class="w-full md:w-1/2 min-h-0 relative" style="min-height: 300px;"><canvas id="chartClientes" style="display:block; width:100% !important; height:100% !important;"></canvas></div>
            </div>
        </div>
    </div>

    <!-- Tab 4: Saldo 2da x Cliente -->
    <div id="contentSaldo2daCliente" class="tab-content flex-1 flex flex-col gap-4 min-h-0">
        <!-- Detalle por Cliente de Saldos 2da: Tabla + Gráfico -->
        <div class="bg-white rounded-xl shadow-sm p-4 border border-gray-200 flex flex-col relative gap-2">
            <div class="flex items-center justify-between mb-0">
                <h3 class="text-gray-600 font-bold">Detalle por Cliente de Saldos 2da</h3>
                <span id="clientePeriodo2da" class="text-lg text-gray-700 font-bold"></span>
            </div>
            
            <!-- Contenedor flex para tabla y gráfico lado a lado -->
            <div class="flex-1 flex flex-col md:flex-row gap-4 min-h-0">
                <!-- Tabla de clientes (50% ancho en desktop) -->
                <div class="w-full md:w-1/2 overflow-auto min-h-0 max-h-full">
                    <table id="tablaClientes2da" class="w-full text-sm">
                        <thead class="bg-gray-800 sticky top-0">
                            <tr class="text-left text-xs font-bold text-white">
                                <th class="py-2 px-2 border-b">Cliente</th>
                                <th class="py-2 px-2 border-b">Tipo</th>
                                <th class="py-2 px-2 border-b text-right">Prendas Pedido</th>
                                <th class="py-2 px-2 border-b text-right">Prendas Ingreso Neto</th>
                                <th class="py-2 px-2 border-b text-right">Saldos 2da</th>
                                <th class="py-2 px-2 border-b text-right">%Saldo 2da</th>
                            </tr>
                        </thead>
                        <tbody id="tablaClientes2daBody" class="text-gray-700">
                            <tr><td colspan="6" class="py-2 text-center text-gray-400">Cargando...</td></tr>
                        </tbody>
                    </table>
                </div>

                <!-- Gráfico de clientes (50% ancho en desktop) -->
                <div class="w-full md:w-1/2 min-h-0 relative" style="min-height: 300px;"><canvas id="chartClientes2da" style="display:block; width:100% !important; height:100% !important;"></canvas></div>
            </div>
        </div>
    </div>

    <!-- Tab 5: Saldo 3ra x Cliente -->
    <div id="contentSaldo3raCliente" class="tab-content flex-1 flex flex-col gap-4 min-h-0">
        <!-- Detalle por Cliente de Saldos 3ra: Tabla + Gráfico -->
        <div class="bg-white rounded-xl shadow-sm p-4 border border-gray-200 flex flex-col relative gap-2">
            <div class="flex items-center justify-between mb-0">
                <h3 class="text-gray-600 font-bold">Detalle por Cliente de Saldos 3ra</h3>
                <span id="clientePeriodo3ra" class="text-lg text-gray-700 font-bold"></span>
            </div>
            
            <!-- Contenedor flex para tabla y gráfico lado a lado -->
            <div class="flex-1 flex flex-col md:flex-row gap-4 min-h-0">
                <!-- Tabla de clientes (50% ancho en desktop) -->
                <div class="w-full md:w-1/2 overflow-auto min-h-0 max-h-full">
                    <table id="tablaClientes3ra" class="w-full text-sm">
                        <thead class="bg-gray-800 sticky top-0">
                            <tr class="text-left text-xs font-bold text-white">
                                <th class="py-2 px-2 border-b">Cliente</th>
                                <th class="py-2 px-2 border-b">Tipo</th>
                                <th class="py-2 px-2 border-b text-right">Prendas Pedido</th>
                                <th class="py-2 px-2 border-b text-right">Prendas Ingreso Neto</th>
                                <th class="py-2 px-2 border-b text-right">Saldos 3ra</th>
                                <th class="py-2 px-2 border-b text-right">%Saldo 3ra</th>
                            </tr>
                        </thead>
                        <tbody id="tablaClientes3raBody" class="text-gray-700">
                            <tr><td colspan="6" class="py-2 text-center text-gray-400">Cargando...</td></tr>
                        </tbody>
                    </table>
                </div>

                <!-- Gráfico de clientes (50% ancho en desktop) -->
                <div class="w-full md:w-1/2 min-h-0 relative" style="min-height: 300px;"><canvas id="chartClientes3ra" style="display:block; width:100% !important; height:100% !important;"></canvas></div>
            </div>
        </div>
    </div>

    <!-- Tab 6: HOD -->
    <div id="contentHOD" class="tab-content flex-1 flex flex-col gap-4 min-h-0">
        <!-- Detalle por Cliente de Saldos 1ra: Tabla + Gráfico (igual a Tab 3) -->
        <div class="bg-white rounded-xl shadow-sm p-4 border border-gray-200 flex flex-col relative gap-2">
            <div class="flex items-center justify-between mb-0">
                <h3 class="text-gray-600 font-bold">Detalle por Cliente de Pds Despachadas</h3>
                <span id="hodPeriodo" class="text-lg text-gray-700 font-bold"></span>
            </div>
            
            <!-- Contenedor flex para tabla y gráfico lado a lado -->
            <div class="flex-1 flex flex-col md:flex-row gap-4 min-h-0">
                <!-- Tabla de clientes (50% ancho en desktop) -->
                <div class="w-full md:w-1/2 overflow-auto min-h-0 max-h-full">
                    <table id="tablaClientesHOD" class="w-full text-sm">
                        <thead class="bg-gray-800 sticky top-0">
                            <tr class="text-left text-xs font-bold text-white">
                                <th class="py-2 px-2 border-b">Cliente</th>
                                <th class="py-2 px-2 border-b">Tipo</th>
                                <th class="py-2 px-2 border-b text-right">Prendas Pedido</th>
                                <th class="py-2 px-2 border-b text-right">Prendas Ingreso Neto</th>
                                <th class="py-2 px-2 border-b text-right">Pds desp.</th>
                                <th class="py-2 px-2 border-b text-right">%Desp.</th>
                            </tr>
                        </thead>
                        <tbody id="tablaClientesHODBody" class="text-gray-700">
                            <tr><td colspan="6" class="py-2 text-center text-gray-400">Cargando...</td></tr>
                        </tbody>
                    </table>
                </div>

                <!-- Gráfico de clientes (50% ancho en desktop) -->
                <div class="w-full md:w-1/2 min-h-0 relative bg-blue-50 rounded-lg p-3" style="min-height: 300px;"><canvas id="chartClientesHOD" style="display:block; width:100% !important; height:100% !important;"></canvas></div>
            </div>
        </div>
    </div>

    <!-- Modal: Detalle %Saldo 1ra por Cliente -->
    <div id="modalSaldo1raDetalle" class="hidden fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black opacity-40" id="modalSaldoOverlay"></div>
        <div class="bg-white rounded-lg shadow-lg w-11/12 md:w-3/4 lg:w-2/3 z-50 flex flex-col max-h-[80vh] p-6">
            <div class="flex items-center justify-between pb-4 border-b sticky top-0 bg-white z-20 -mx-6 px-6 -mt-6 pt-6">
                <h4 id="modalSaldoTitle" class="text-lg font-bold">Cliente - %Saldo 1ra</h4>
                <button id="modalSaldoClose" class="text-gray-600 hover:text-gray-900">Cerrar ✕</button>
            </div>
            <div class="overflow-auto flex-1 mt-4">
                <table id="modalSaldoTable" class="w-full text-sm">
                    <thead class="bg-gray-100 sticky top-0 z-10">
                        <tr class="text-left text-xs font-bold text-gray-700">
                            <th class="py-2 px-2 border whitespace-normal">Estilo</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Pedido</th>
                            <th class="py-1 px-1 border text-right hidden text-xs">Prendas<br>Pedido HM</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Prog.</th>
                            <th class="py-1 px-1 border text-right text-xs">%Prog</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Girado</th>
                            <th class="py-1 px-1 border text-right text-xs">%Giro</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Cortadas<br>Neto</th>
                            <th class="py-1 px-1 border text-right text-xs">%Corte</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Ingreso<br>Neto</th>
                            <th class="py-1 px-1 border text-right text-xs">%Ing.</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Despacho<br>Almacen</th>
                            <th class="py-1 px-1 border text-right text-xs">%Desp.</th>
                        </tr>
                    </thead>
                    <tbody id="modalSaldoBody" class="text-gray-700"></tbody>
                    <tfoot>
                        <tr id="modalSaldoTotalRow" class="bg-gray-50 font-bold sticky bottom-0 z-10">
                            <td class="py-2 px-2 border">TOTAL</td>
                            <td id="modalTotalPedido" class="py-1 px-1 border text-right">0</td>
                            <td id="modalTotalPedidoHM" class="py-1 px-1 border text-right hidden">0</td>
                            <td id="modalTotalProg" class="py-1 px-1 border text-right">0</td>
                            <td id="modalTotalProgPct" class="py-1 px-1 border text-right">0%</td>
                            <td id="modalTotalGirado" class="py-1 px-1 border text-right">0</td>
                            <td id="modalTotalGiroPct" class="py-1 px-1 border text-right">0%</td>
                            <td id="modalTotalCortadas" class="py-1 px-1 border text-right">0</td>
                            <td id="modalTotalCortasPct" class="py-1 px-1 border text-right">0%</td>
                            <td id="modalTotalIngresoNeto" class="py-1 px-1 border text-right">0</td>
                            <td id="modalTotalIngresoPct" class="py-1 px-1 border text-right">0%</td>
                            <td id="modalTotalDespachoAlmacen" class="py-1 px-1 border text-right">0</td>
                            <td id="modalTotalDespPct" class="py-1 px-1 border text-right">0%</td>
                        </tr>
                    </tfoot>
                </table>
            </div>
        </div>
    </div>

    <!-- Modal: Detalle %Saldo 2da por Cliente -->
    <div id="modalSaldo2daDetalle" class="hidden fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black opacity-40" id="modalSaldo2daOverlay"></div>
        <div class="bg-white rounded-lg shadow-lg w-11/12 md:w-3/4 lg:w-2/3 z-50 flex flex-col max-h-[80vh] p-6">
            <div class="flex items-center justify-between pb-4 border-b sticky top-0 bg-white z-20 -mx-6 px-6 -mt-6 pt-6">
                <h4 id="modalSaldo2daTitle" class="text-lg font-bold">Cliente - %Saldo 2da</h4>
                <button id="modalSaldo2daClose" class="text-gray-600 hover:text-gray-900">Cerrar ✕</button>
            </div>
            <div class="overflow-auto flex-1 mt-4">
                <table id="modalSaldo2daTable" class="w-full text-sm">
                    <thead class="bg-gray-100 sticky top-0 z-10">
                        <tr class="text-left text-xs font-bold text-gray-700">
                            <th class="py-2 px-2 border whitespace-normal">Estilo</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Pedido</th>
                            <th class="py-1 px-1 border text-right hidden text-xs">Prendas<br>Pedido HM</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Prog.</th>
                            <th class="py-1 px-1 border text-right text-xs">%Prog</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Girado</th>
                            <th class="py-1 px-1 border text-right text-xs">%Giro</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Cortadas<br>Neto</th>
                            <th class="py-1 px-1 border text-right text-xs">%Corte</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Ingreso<br>Neto</th>
                            <th class="py-1 px-1 border text-right text-xs">%Ing.</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Despacho<br>Almacen</th>
                            <th class="py-1 px-1 border text-right text-xs">%Desp.</th>
                        </tr>
                    </thead>
                    <tbody id="modalSaldo2daBody" class="text-gray-700"></tbody>
                    <tfoot>
                        <tr id="modalSaldo2daTotalRow" class="bg-gray-50 font-bold sticky bottom-0 z-10">
                            <td class="py-2 px-2 border">TOTAL</td>
                            <td id="modal2daTotalPedido" class="py-1 px-1 border text-right">0</td>
                            <td id="modal2daTotalPedidoHM" class="py-1 px-1 border text-right hidden">0</td>
                            <td id="modal2daTotalProg" class="py-1 px-1 border text-right">0</td>
                            <td id="modal2daTotalProgPct" class="py-1 px-1 border text-right">0%</td>
                            <td id="modal2daTotalGirado" class="py-1 px-1 border text-right">0</td>
                            <td id="modal2daTotalGiroPct" class="py-1 px-1 border text-right">0%</td>
                            <td id="modal2daTotalCortadas" class="py-1 px-1 border text-right">0</td>
                            <td id="modal2daTotalCortasPct" class="py-1 px-1 border text-right">0%</td>
                            <td id="modal2daTotalIngresoNeto" class="py-1 px-1 border text-right">0</td>
                            <td id="modal2daTotalIngresoPct" class="py-1 px-1 border text-right">0%</td>
                            <td id="modal2daTotalDespachoAlmacen" class="py-1 px-1 border text-right">0</td>
                            <td id="modal2daTotalDespPct" class="py-1 px-1 border text-right">0%</td>
                        </tr>
                    </tfoot>
                </table>
            </div>
        </div>
    </div>

    <!-- Modal: Detalle %Saldo 3ra por Cliente -->
    <div id="modalSaldo3raDetalle" class="hidden fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black opacity-40" id="modalSaldo3raOverlay"></div>
        <div class="bg-white rounded-lg shadow-lg w-11/12 md:w-3/4 lg:w-2/3 z-50 flex flex-col max-h-[80vh] p-6">
            <div class="flex items-center justify-between pb-4 border-b sticky top-0 bg-white z-20 -mx-6 px-6 -mt-6 pt-6">
                <h4 id="modalSaldo3raTitle" class="text-lg font-bold">Cliente - %Saldo 3ra</h4>
                <button id="modalSaldo3raClose" class="text-gray-600 hover:text-gray-900">Cerrar ✕</button>
            </div>
            <div class="overflow-auto flex-1 mt-4">
                <table id="modalSaldo3raTable" class="w-full text-sm">
                    <thead class="bg-gray-100 sticky top-0 z-10">
                        <tr class="text-left text-xs font-bold text-gray-700">
                            <th class="py-2 px-2 border whitespace-normal">Estilo</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Pedido</th>
                            <th class="py-1 px-1 border text-right hidden text-xs">Prendas<br>Pedido HM</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Prog.</th>
                            <th class="py-1 px-1 border text-right text-xs">%Prog</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Girado</th>
                            <th class="py-1 px-1 border text-right text-xs">%Giro</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Cortadas<br>Neto</th>
                            <th class="py-1 px-1 border text-right text-xs">%Corte</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Ingreso<br>Neto</th>
                            <th class="py-1 px-1 border text-right text-xs">%Ing.</th>
                            <th class="py-1 px-1 border text-right whitespace-normal text-xs">Prendas<br>Despacho<br>Almacen</th>
                            <th class="py-1 px-1 border text-right text-xs">%Desp.</th>
                        </tr>
                    </thead>
                    <tbody id="modalSaldo3raBody" class="text-gray-700"></tbody>
                    <tfoot>
                        <tr id="modalSaldo3raTotalRow" class="bg-gray-50 font-bold sticky bottom-0 z-10">
                            <td class="py-2 px-2 border">TOTAL</td>
                            <td id="modal3raTotalPedido" class="py-1 px-1 border text-right">0</td>
                            <td id="modal3raTotalPedidoHM" class="py-1 px-1 border text-right hidden">0</td>
                            <td id="modal3raTotalProg" class="py-1 px-1 border text-right">0</td>
                            <td id="modal3raTotalProgPct" class="py-1 px-1 border text-right">0%</td>
                            <td id="modal3raTotalGirado" class="py-1 px-1 border text-right">0</td>
                            <td id="modal3raTotalGiroPct" class="py-1 px-1 border text-right">0%</td>
                            <td id="modal3raTotalCortadas" class="py-1 px-1 border text-right">0</td>
                            <td id="modal3raTotalCortasPct" class="py-1 px-1 border text-right">0%</td>
                            <td id="modal3raTotalIngresoNeto" class="py-1 px-1 border text-right">0</td>
                            <td id="modal3raTotalIngresoPct" class="py-1 px-1 border text-right">0%</td>
                            <td id="modal3raTotalDespachoAlmacen" class="py-1 px-1 border text-right">0</td>
                            <td id="modal3raTotalDespPct" class="py-1 px-1 border text-right">0%</td>
                        </tr>
                    </tfoot>
                </table>
            </div>
        </div>
    </div>

    <!-- Modal: Ingreso Neto vs Diferencia por Cliente -->
    <div id="modalClienteChart" class="hidden fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black opacity-40" id="modalClienteChartOverlay"></div>
        <div class="bg-white rounded-lg shadow-lg w-11/12 md:w-4/5 lg:w-3/4 z-50 flex flex-col max-h-[85vh] p-6">
            <div class="flex items-center justify-between pb-4 border-b sticky top-0 bg-white z-20 -mx-6 px-6 -mt-6 pt-6">
                <h4 id="modalClienteChartTitle" class="text-lg font-bold">Ingreso Neto vs Diferencia por Cliente</h4>
                <div class="flex items-center gap-4">
                    <div class="flex items-center gap-2">
                        <span class="text-xs font-bold text-gray-500 uppercase">Cliente:</span>
                        <select id="modalClienteFilter" class="filter-select bg-white min-w-[180px]">
                            <option value="">Todos los clientes</option>
                        </select>
                    </div>
                    <button id="modalClienteChartClose" class="text-gray-600 hover:text-gray-900 font-semibold">Cerrar ✕</button>
                </div>
            </div>
            <div class="flex-1 mt-4 min-h-0" style="min-height: 400px;">
                <canvas id="chartClienteModal" style="width:100% !important; height:100% !important; display:block;"></canvas>
            </div>
        </div>
    </div>

    <script>
        // URL proporcionada por el usuario
        const SCRIPT_URL = "https://script.google.com/macros/s/AKfycby-NzOipiiNl8FdYKArI1zR1iSIWH1a6N22EVS418QwSd1by2oKL1Uf-I2f48onxYDT4Q/exec";
        const SHEET_ID = "15TXF2s-N9Q38BCz9pE31WCZqTLAGQIi5AqnFgkZaAhw";
        
        // Variable global para almacenar los datos cargados desde la hoja 'resumen'
        let rawDataResumen = [];
        let rawDataBase = [];

        // Función para cambiar entre pestañas
        function switchTab(tabName) {
            // Ocultar todos los contenidos
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Desactivar todos los botones de tab
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Activar el contenido y botón correspondiente
            if (tabName === 'pdsRegularizar') {
                document.getElementById('contentPdsRegularizar').classList.add('active');
                document.getElementById('tabPdsRegularizar').classList.add('active');
                // Forzar redimensionamiento del gráfico
                setTimeout(() => {
                    if (charts.c1) charts.c1.resize();
                }, 50);
                // Recargar acciones para la pestaña actual
                cargarAcciones().catch(e => console.warn('Error recargando acciones:', e));
            } else if (tabName === 'saldos') {
                document.getElementById('contentSaldos').classList.add('active');
                document.getElementById('tabSaldos').classList.add('active');
                // Forzar redimensionamiento de los gráficos
                setTimeout(() => {
                    if (charts.c5) charts.c5.resize();
                    if (charts.c2) charts.c2.resize();
                    if (charts.c3) charts.c3.resize();
                }, 50);
                // Recargar acciones para la pestaña actual
                cargarAcciones().catch(e => console.warn('Error recargando acciones:', e));
            } else if (tabName === 'saldo1raCliente') {
                document.getElementById('contentSaldo1raCliente').classList.add('active');
                document.getElementById('tabSaldo1raCliente').classList.add('active');
                // Forzar redimensionamiento del gráfico
                setTimeout(() => {
                    if (charts.clientes) charts.clientes.resize();
                }, 50);
                // Recargar acciones para la pestaña actual
                cargarAcciones().catch(e => console.warn('Error recargando acciones:', e));
                // Limpiar caché y recargar datos de clientes
                cache.clientes = null;
                cache.timestamp = null;
                cargarDatosClientes().catch(e => console.warn('Error recargando clientes:', e));
            } else if (tabName === 'saldo2daCliente') {
                document.getElementById('contentSaldo2daCliente').classList.add('active');
                document.getElementById('tabSaldo2daCliente').classList.add('active');
                // Forzar redimensionamiento del gráfico
                setTimeout(() => {
                    if (charts.clientes2da) charts.clientes2da.resize();
                }, 50);
                // Recargar acciones para la pestaña actual
                cargarAcciones().catch(e => console.warn('Error recargando acciones:', e));
                // Limpiar caché y recargar datos de clientes
                cache.clientes = null;
                cache.timestamp = null;
                cargarDatosClientes().catch(e => console.warn('Error recargando clientes:', e));
            } else if (tabName === 'saldo3raCliente') {
                document.getElementById('contentSaldo3raCliente').classList.add('active');
                document.getElementById('tabSaldo3raCliente').classList.add('active');
                // Forzar redimensionamiento del gráfico
                setTimeout(() => {
                    if (charts.clientes3ra) charts.clientes3ra.resize();
                }, 50);
                // Recargar acciones para la pestaña actual
                cargarAcciones().catch(e => console.warn('Error recargando acciones:', e));
                // Limpiar caché y recargar datos de clientes
                cache.clientes = null;
                cache.timestamp = null;
                cargarDatosClientes().catch(e => console.warn('Error recargando clientes:', e));
            } else if (tabName === 'hod') {
                document.getElementById('contentHOD').classList.add('active');
                document.getElementById('tabHOD').classList.add('active');
                // Forzar redimensionamiento del gráfico
                setTimeout(() => {
                    if (charts.clientesHOD) charts.clientesHOD.resize();
                }, 50);
                // Recargar acciones para la pestaña actual
                cargarAcciones().catch(e => console.warn('Error recargando acciones:', e));
                // Limpiar caché y recargar datos de clientes
                cache.clientes = null;
                cache.timestamp = null;
                cargarDatosClientes().catch(e => console.warn('Error recargando clientes:', e));
            }

        }

        // Añadir/Remover botones Guardar / Cancelar junto al '+'
        function addSaveCancelButtons(tr, columns) {
            const info = document.getElementById('accionesFilterInfo');
            if (!info) return;
            // evitar duplicados
            removeSaveCancelButtons();

            const btnGuardar = document.createElement('button');
            btnGuardar.id = 'btnGuardarAccion';
            btnGuardar.className = 'ml-2 inline-flex items-center gap-2 px-3 py-1 rounded bg-green-600 text-white';
            btnGuardar.textContent = 'Guardar';
            btnGuardar.addEventListener('click', async () => {
                // validar campos: todos los td (excepto pestaña que no existe) deben tener valor
                const cells = Array.from(tr.querySelectorAll('td'));
                const dataOk = cells.every(td => {
                    const input = td.querySelector('input[type="date"]');
                    const v = input ? (input.value || '') : (td.textContent || '').trim();
                    return String(v).trim() !== '';
                });
                if (!dataOk) {
                    alert('Por favor complete todos los campos antes de guardar.');
                    return;
                }

                const confirmed = await showConfirm('¿Quiere registrar la Acción?');
                if (confirmed) {
                    attemptSaveAccion(tr, columns);
                }
            });

            const btnCancelar = document.createElement('button');
            btnCancelar.id = 'btnCancelarAccion';
            btnCancelar.className = 'ml-2 inline-flex items-center gap-2 px-3 py-1 rounded bg-gray-300 text-gray-700';
            btnCancelar.textContent = 'Cancelar';
            btnCancelar.addEventListener('click', () => {
                tr.remove();
                removeSaveCancelButtons();
            });

            info.appendChild(btnGuardar);
            info.appendChild(btnCancelar);
        }

        function removeSaveCancelButtons() {
            const btnG = document.getElementById('btnGuardarAccion');
            const btnC = document.getElementById('btnCancelarAccion');
            if (btnG) btnG.remove();
            if (btnC) btnC.remove();
        }

        // Modal confirm returning Promise<boolean>
        function showConfirm(message) {
            return new Promise(resolve => {
                // crear overlay
                const overlay = document.createElement('div');
                overlay.style.position = 'fixed'; overlay.style.inset = '0'; overlay.style.display = 'flex';
                overlay.style.alignItems = 'center'; overlay.style.justifyContent = 'center'; overlay.style.zIndex = 9999;
                overlay.style.background = 'rgba(0,0,0,0.4)';

                const box = document.createElement('div');
                box.style.background = 'white'; box.style.borderRadius = '8px'; box.style.padding = '18px'; box.style.minWidth = '320px';
                box.style.boxShadow = '0 8px 24px rgba(0,0,0,0.2)';

                const msg = document.createElement('div'); msg.textContent = message; msg.style.marginBottom = '12px';
                const btnRow = document.createElement('div'); btnRow.style.display = 'flex'; btnRow.style.justifyContent = 'flex-end'; btnRow.style.gap = '8px';

                const noBtn = document.createElement('button'); noBtn.textContent = 'No'; noBtn.className = 'px-3 py-1 rounded bg-gray-200';
                const yesBtn = document.createElement('button'); yesBtn.textContent = 'Si'; yesBtn.className = 'px-3 py-1 rounded bg-blue-600 text-white';

                noBtn.addEventListener('click', () => { overlay.remove(); resolve(false); });
                yesBtn.addEventListener('click', () => { overlay.remove(); resolve(true); });

                btnRow.appendChild(noBtn); btnRow.appendChild(yesBtn);
                box.appendChild(msg); box.appendChild(btnRow);
                overlay.appendChild(box);
                document.body.appendChild(overlay);
            });
        }
        
        let charts = {};
        let isSavingAccion = false;
        const monthNames = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Set", "Oct", "Nov", "Dic"];
        
        // Caché para optimizar llamadas repetidas
        const cache = {
            dashboard: null,
            clientes: null,
            lastParams: null,
            timestamp: null,
            TTL: 30000 // 30 segundos de validez
        };
        
        // Funciones para actualizar el estado de conexión
        function setConnectionStatus(status, text) {
            const statusText = document.getElementById('statusText');
            const statusDot = document.getElementById('statusDot');
            if (statusText) statusText.textContent = text;
            if (statusDot) {
                statusDot.className = 'status-indicator';
                statusDot.classList.add(`status-${status}`);
            }
        }

        // Helper: formato corto para ejes (5,000 -> 5k, 10,000 -> 10k)
        function formatShortNumber(val) {
            if (val === null || val === undefined) return '' + val;
            const n = Number(val);
            if (isNaN(n)) return String(val);
            const abs = Math.abs(n);
            if (abs >= 1000) {
                const k = n / 1000;
                return (Number.isInteger(k) ? k.toString() : k.toFixed(1).replace(/\.0$/,'')) + 'k';
            }
            return new Intl.NumberFormat('es-PE').format(n);
        }

        document.addEventListener('DOMContentLoaded', async () => {
            // Cargar años en segundo plano sin bloquear
            cargarAniosDesdeBase().catch(e => console.warn('Error cargando años:', e));
            
            establecerFechasPorDefecto();
            initCharts();
            cargarDatosIniciales(); // Carga paralela optimizada
            
            // Debounce para evitar múltiples llamadas al cambiar filtros
            // Solo aplicar a los selectores de fecha principales, no al modal
            let filterTimeout;
            const filterSelects = ['desdeAnio', 'desdeMes', 'hastaAnio', 'hastaMes'];
            filterSelects.forEach(selId => {
                const sel = document.getElementById(selId);
                if (sel) {
                    sel.addEventListener('change', () => {
                        clearTimeout(filterTimeout);
                        filterTimeout = setTimeout(() => {
                            // Procesar datos ya cargados con nuevos filtros
                            procesarDatosOptimizado();
                        }, 300); // 300ms de espera
                    });
                }
            });
        });
        
        // Cargar datos iniciales usando Google Visualization API (más rápido)
        function cargarDatosIniciales() {
            const loading = document.getElementById('mainLoader');
            const loaderText = document.getElementById('loaderText');
            loading.classList.remove('hidden');
            setConnectionStatus('loading', 'Cargando...');
            
            try {
                // Cargar datos desde Google Sheets usando la API de Visualization
                loaderText.textContent = 'Cargando desde Google Sheets...';
                const script = document.createElement('script');
                script.src = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?sheet=resumen&tqx=responseHandler:loadResumenCallback`;
                script.onerror = () => {
                    console.error('Error cargando datos desde Google Sheets');
                    setConnectionStatus('error', 'Error de conexión');
                    loading.classList.add('hidden');
                    alert('Error de conexión con Google Sheets. Verifica tu conexión a internet.');
                };
                document.body.appendChild(script);
            } catch (error) {
                console.error("Error en carga inicial:", error);
                setConnectionStatus('error', 'Error de conexión');
                loading.classList.add('hidden');
            }
        }
        
        // Callback que recibe los datos desde Google Visualization API
        window.loadResumenCallback = function(jsonResponse) {
            const loading = document.getElementById('mainLoader');
            const loaderText = document.getElementById('loaderText');
            
            try {
                if (!jsonResponse || !jsonResponse.table) {
                    throw new Error("Datos inválidos desde Google Sheets.");
                }
                
                // Extraer datos de la respuesta
                const cols = jsonResponse.table.cols.map(col => col.label || col.id || '');
                const rows = jsonResponse.table.rows.map(r => r.c.map(cell => (cell && cell.v !== null) ? cell.v : ""));
                
                // Guardar datos en variable global
                rawDataResumen = [cols, ...rows];
                
                console.log('Datos cargados:', rawDataResumen.length, 'filas');
                
                // Procesar y renderizar los gráficos
                loaderText.textContent = 'Renderizando gráficos...';
                procesarDatosOptimizado();
                
                // Ocultar loader
                loading.classList.add('hidden');
                setConnectionStatus('success', 'Conectado');
                
                // PRIORIDAD 2: Cargar datos secundarios (Base para cálculos de saldos)
                cargarDatosBase().catch(e => console.warn('Error cargando base:', e));
                
                // PRIORIDAD 3: Cargar tablas secundarias en segundo plano
                Promise.all([
                    cargarDatosClientes().catch(e => console.warn('Error cargando clientes:', e)),
                    cargarAcciones().catch(e => console.warn('Error cargando acciones:', e))
                ]).then(() => {
                    console.log('Todos los datos cargados completamente');
                }).catch(error => {
                    console.error("Error en carga secundaria:", error);
                });
                
            } catch (error) {
                console.error('Error procesando datos:', error);
                loading.classList.add('hidden');
                setConnectionStatus('error', 'Error procesando datos');
                alert('Error procesando datos: ' + error.message);
            }
        };
        
        // Cargar datos de la hoja 'base' para cálculos de saldos
        async function cargarDatosBase() {
            try {
                const script = document.createElement('script');
                script.src = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?sheet=base&tqx=responseHandler:loadBaseCallback`;
                script.onerror = () => console.warn('Error cargando hoja base');
                document.body.appendChild(script);
            } catch (error) {
                console.warn('Error cargando datos base:', error);
            }
        }
        
        // Callback para datos de la hoja 'base'
        window.loadBaseCallback = function(jsonResponse) {
            try {
                if (!jsonResponse || !jsonResponse.table) return;
                
                const cols = jsonResponse.table.cols.map(col => col.label || col.id || '');
                const rows = jsonResponse.table.rows.map(r => r.c.map(cell => (cell && cell.v !== null) ? cell.v : ""));
                
                rawDataBase = [cols, ...rows];
                console.log('Datos base cargados:', rawDataBase.length, 'filas');
                
                // Re-procesar con datos de saldos ahora disponibles
                procesarDatosOptimizado();
            } catch (error) {
                console.warn('Error procesando datos base:', error);
            }
        };

        // Cargar años disponibles desde la hoja 'base' (servidor) y poblar selects
        async function cargarAniosDesdeBase() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);

                const resp = await fetch(SCRIPT_URL, {
                    method: 'POST',
                    redirect: 'follow',
                    credentials: 'omit',
                    signal: controller.signal,
                    body: JSON.stringify({ action: 'getAvailableYears' })
                });

                clearTimeout(timeoutId);
                const result = await resp.json();
                if (result.status === 'success' && Array.isArray(result.data)) {
                    const years = result.data;
                    const desdeSel = document.getElementById('desdeAnio');
                    const hastaSel = document.getElementById('hastaAnio');
                    if (!desdeSel || !hastaSel) return;

                    // Limpiar opciones actuales
                    desdeSel.innerHTML = '';
                    hastaSel.innerHTML = '';

                    // Asegurar que sean únicos y ordenados
                    const unique = Array.from(new Set(years.map(y => String(y))));
                    unique.forEach(y => {
                        const o1 = document.createElement('option'); o1.value = y; o1.textContent = y;
                        const o2 = document.createElement('option'); o2.value = y; o2.textContent = y;
                        desdeSel.appendChild(o1);
                        hastaSel.appendChild(o2);
                    });

                    // Si no se obtuvo ningún año, mantener las opciones estáticas existentes
                    if (unique.length === 0) {
                        // dejar tal cual; no hacer nada
                    }
                } else {
                    console.warn('No se obtuvieron años desde el servidor:', result && result.message);
                }
            } catch (e) {
                if (e.name === 'AbortError') console.warn('Timeout cargando años');
                else console.error('Error cargando años:', e);
            }
        }

        function establecerFechasPorDefecto() {
            const hoy = new Date();
            const fechaHasta = new Date(hoy.getFullYear(), hoy.getMonth() - 1, 1);
            // Mostrar 9 meses en el filtro: desde = hasta - 8 meses
            const fechaDesde = new Date(fechaHasta.getFullYear(), fechaHasta.getMonth() - 8, 1);

            document.getElementById('hastaAnio').value = fechaHasta.getFullYear();
            document.getElementById('hastaMes').value = fechaHasta.getMonth();
            document.getElementById('desdeAnio').value = fechaDesde.getFullYear();
            document.getElementById('desdeMes').value = fechaDesde.getMonth();
        }

        function actualizarTituloChart1() {
            const desdeAnio = document.getElementById('desdeAnio').value;
            const hastaAnio = document.getElementById('hastaAnio').value;
            const desdeMesIdx = parseInt(document.getElementById('desdeMes').value, 10);
            const hastaMesIdx = parseInt(document.getElementById('hastaMes').value, 10);
            const desdeMes = monthNames[desdeMesIdx] || '';
            const hastaMes = monthNames[hastaMesIdx] || '';

            let rangeText = '';
            if (desdeAnio === hastaAnio) {
                rangeText = `(${desdeMes} - ${hastaMes} ${hastaAnio})`;
            } else {
                rangeText = `(${desdeMes} ${desdeAnio} - ${hastaMes} ${hastaAnio})`;
            }

            const title = `Ingreso Neto vs %Dif. Liquidac. ${rangeText}`;
            const el = document.getElementById('chart1Title');
            if (el) el.innerText = title;
        }

        function actualizarTituloEvolucion() {
            const desdeAnio = document.getElementById('desdeAnio').value;
            const hastaAnio = document.getElementById('hastaAnio').value;
            const desdeMesIdx = parseInt(document.getElementById('desdeMes').value, 10);
            const hastaMesIdx = parseInt(document.getElementById('hastaMes').value, 10);
            const desdeMes = monthNames[desdeMesIdx] || '';
            const hastaMes = monthNames[hastaMesIdx] || '';

            let rangeText = '';
            if (desdeAnio === hastaAnio) {
                rangeText = `(${desdeMes} - ${hastaMes} ${hastaAnio})`;
            } else {
                rangeText = `(${desdeMes} ${desdeAnio} - ${hastaMes} ${hastaAnio})`;
            }

            const title = `Ingreso Neto vs %Saldos ${rangeText}`;
            const el = document.getElementById('chartEvoTitle');
            if (el) el.innerText = title;
        }

        function renderChart1Legend() {
            const container = document.getElementById('chart1Legend');
            if (!container || !charts.c1) return;
            container.innerHTML = '';

            charts.c1.data.datasets.forEach((ds, i) => {
                // Crear item
                const item = document.createElement('div');
                item.style.display = 'inline-flex';
                item.style.alignItems = 'center';
                item.style.gap = '6px';
                item.style.cursor = 'pointer';

                const sw = document.createElement('span');
                sw.style.display = 'inline-block';
                sw.style.width = '12px';
                sw.style.height = '12px';
                sw.style.borderRadius = '50%';
                sw.style.boxSizing = 'border-box';
                // color prefer backgroundColor then borderColor
                const color = (Array.isArray(ds.backgroundColor) ? ds.backgroundColor[0] : ds.backgroundColor) || ds.borderColor || '#666';
                sw.style.background = color;

                const label = document.createElement('span');
                label.textContent = ds.label || '';
                label.style.fontSize = '13px';
                label.style.color = '#374151';

                // Dim if hidden
                const hidden = !charts.c1.isDatasetVisible(i);
                if (hidden) {
                    sw.style.opacity = '0.4';
                    label.style.opacity = '0.4';
                }

                item.appendChild(sw);
                item.appendChild(label);

                item.addEventListener('click', () => {
                    const vis = charts.c1.isDatasetVisible(i);
                    charts.c1.setDatasetVisibility(i, !vis);
                    charts.c1.update();
                    renderChart1Legend();
                });

                container.appendChild(item);
            });
        }

        function initCharts() {
            // Función helper para dibujar texto con formato especial para la parte [$##]
            const drawFormattedText = (ctx, text, x, y, fontSize, isRight = false) => {
                const match = text.match(/^(.+?)\s*\[\$(.+?)\]$/);
                if (match) {
                    const mainPart = match[1];
                    const smallPart = '[$' + match[2] + ']';
                    
                    // Medir el texto principal (en negritas)
                    const mainMetrics = ctx.measureText(mainPart);
                    const mainWidth = mainMetrics.width;
                    
                    // Cambiar a fuente más pequeña y no negritas para la parte pequeña
                    const smallFontSize = fontSize - 1;
                    const currentFont = ctx.font;
                    ctx.font = smallFontSize + 'px ' + currentFont.split('px')[1];
                    
                    const smallMetrics = ctx.measureText(smallPart);
                    const smallWidth = smallMetrics.width;
                    
                    // Dibujar ambas partes
                    if (isRight) {
                        // Alineado a la derecha: pequeño + principal
                        ctx.fillText(smallPart, x - mainWidth - 2, y);
                        ctx.font = currentFont; // Restaurar font negritas
                        ctx.fillText(mainPart, x - smallWidth - 4, y);
                    } else {
                        // Alineado a la izquierda: principal + pequeño
                        ctx.font = currentFont; // Restaurar font negritas
                        ctx.fillText(mainPart, x, y);
                        ctx.font = smallFontSize + 'px ' + currentFont.split('px')[1];
                        ctx.fillText(smallPart, x + mainWidth + 2, y);
                    }
                    
                    ctx.font = currentFont; // Restaurar font original
                } else {
                    ctx.fillText(text, x, y);
                }
            };
            
            // Plugin para mostrar etiquetas en la base de las barras (3px entre eje X y dato)
            const barBaseLabelPlugin = {
                id: 'barBaseLabels',
                afterDatasetsDraw(chart, args, options) {
                    const ctx = chart.ctx;
                    const chartArea = chart.chartArea;

                    // ---------- BARRAS: etiquetas en la base (apiladas si hay varias series)
                    const barDatasetIndices = chart.data.datasets.map((d, i) => {
                        const m = chart.getDatasetMeta(i);
                        return (m && m.type === 'bar' && chart.isDatasetVisible(i)) ? i : -1;
                    }).filter(i => i >= 0);

                    const isHorizontalChart = chart.options && chart.options.indexAxis === 'y';

                    chart.data.datasets.forEach((dataset, datasetIndex) => {
                        const meta = chart.getDatasetMeta(datasetIndex);
                        // Solo para barras y visibles
                        if (!meta || meta.type !== 'bar' || !chart.isDatasetVisible(datasetIndex)) return;

                        const positionOffset = barDatasetIndices.indexOf(datasetIndex);
                        meta.data.forEach((bar, index) => {
                            const value = dataset.data[index];
                            if (value === null || value === undefined) return;

                            const x = bar.x;
                            const base = bar.base;

                            const padding = (options && options.padding) || 3;
                            const fontSize = (options && options.fontSize) || 14;
                            const fontFamily = (options && options.fontFamily) || 'Arial';
                            ctx.font = 'bold ' + fontSize + 'px ' + fontFamily;

                            let text = value;
                            if (typeof value === 'number') {
                                text = new Intl.NumberFormat('es-PE').format(value);
                                
                                // Agregar cálculo ×12 para gráficos de Saldos (chart5, chart2, chart3)
                                const chartId = chart && chart.canvas && chart.canvas.id;
                                const isSaldoChart = ['chart5', 'chart2', 'chart3'].includes(chartId);
                                const isSaldoDataset = dataset.label && dataset.label.toLowerCase().includes('saldos');
                                
                                if (isSaldoChart && isSaldoDataset) {
                                    const valueMultiplied = value * 12;
                                    const multipliedText = new Intl.NumberFormat('es-PE').format(valueMultiplied);
                                    text = text + 'pds [$' + multipliedText + ']';
                                }
                            }

                            const isIngresoNeto = dataset.label && dataset.label.toLowerCase().includes('ingreso');
                            const paddingX = 6;
                            const paddingY = 3;

                            const metrics = ctx.measureText(text);
                            const textWidth = metrics.width;
                            const rectWidth = textWidth + paddingX * 2;
                            const rectHeight = fontSize + paddingY * 2;

                            if (isHorizontalChart) {
                                // Para barras horizontales, 'base' es el inicio y 'x' es el extremo
                                const startX = Math.min(x, base);
                                const endX = Math.max(x, base);

                                // Por defecto colocamos la etiqueta cerca de la base (comportamiento de "Saldos 1ra").
                                // Evitamos forzar que chart2/chart3 estén a la derecha para que coincidan con chart5.
                                const desiredPadding = 1; // px entre barra y etiqueta
                                const labelX = startX + padding + 2;

                                // Si hay múltiples datasets de barra, desplazamos ligeramente en Y para evitar solapamiento
                                const stackSpacing = fontSize + 4;
                                const labelY = (bar.y || ((bar.top + bar.bottom) / 2)) + (positionOffset >= 0 ? positionOffset * stackSpacing : 0);

                                const rectX = labelX - paddingX;
                                const rectY = labelY - (rectHeight / 2);

                                // Evitar que la etiqueta quede fuera del area derecha: si se sale, moverla dentro (dentro de la barra)
                                let drawInside = false;
                                if (rectX + rectWidth > chartArea.right) {
                                    drawInside = true;
                                }

                                if (drawInside) {
                                    // Dibujar la etiqueta dentro de la barra (alineada a la derecha dentro de la barra)
                                    const insideX = endX - paddingX;
                                    if (isIngresoNeto) {
                                        const radius = 4;
                                        ctx.fillStyle = (options && options.bgColor) || '#F3F4F6';
                                        ctx.beginPath();
                                        ctx.moveTo(insideX - rectWidth + radius, rectY);
                                        ctx.arcTo(insideX + radius, rectY, insideX + radius, rectY + rectHeight, radius);
                                        ctx.arcTo(insideX + radius, rectY + rectHeight, insideX - rectWidth, rectY + rectHeight, radius);
                                        ctx.arcTo(insideX - rectWidth, rectY + rectHeight, insideX - rectWidth, rectY, radius);
                                        ctx.arcTo(insideX - rectWidth, rectY, insideX - rectWidth + radius, rectY, radius);
                                        ctx.closePath();
                                        ctx.fill();

                                        ctx.fillStyle = (options && options.color) || '#111827';
                                        ctx.textAlign = 'right';
                                        ctx.textBaseline = 'middle';
                                        drawFormattedText(ctx, text, insideX - 2, labelY, fontSize, true);
                                    } else {
                                        ctx.fillStyle = (options && options.color) || '#374151';
                                        ctx.textAlign = 'right';
                                        ctx.textBaseline = 'middle';
                                        drawFormattedText(ctx, text, insideX - 2, labelY, fontSize, true);
                                    }
                                } else {
                                    // Dibujar fuera a la derecha con 1px padding
                                    if (isIngresoNeto) {
                                        const radius = 4;
                                        ctx.fillStyle = (options && options.bgColor) || '#F3F4F6';
                                        ctx.beginPath();
                                        ctx.moveTo(rectX + radius, rectY);
                                        ctx.arcTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + rectHeight, radius);
                                        ctx.arcTo(rectX + rectWidth, rectY + rectHeight, rectX, rectY + rectHeight, radius);
                                        ctx.arcTo(rectX, rectY + rectHeight, rectX, rectY, radius);
                                        ctx.arcTo(rectX, rectY, rectX + rectWidth, rectY, radius);
                                        ctx.closePath();
                                        ctx.fill();

                                        ctx.fillStyle = (options && options.color) || '#111827';
                                        ctx.textAlign = 'left';
                                        ctx.textBaseline = 'middle';
                                        drawFormattedText(ctx, text, labelX, labelY, fontSize, false);
                                    } else {
                                        ctx.fillStyle = (options && options.color) || '#374151';
                                        ctx.textAlign = 'left';
                                        ctx.textBaseline = 'middle';
                                        drawFormattedText(ctx, text, labelX, labelY, fontSize, false);
                                    }
                                }
                            } else {
                                // Vertical bars (comportamiento previo): etiqueta encima de la base
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'bottom';

                                const stackSpacing = fontSize + 6;
                                const verticalOffset = (positionOffset >= 0) ? positionOffset * stackSpacing : 0;
                                const y = base - padding - verticalOffset;

                                const rectX = x - rectWidth / 2;
                                const rectY = y - fontSize - paddingY;

                                if (x >= chartArea.left && x <= chartArea.right && y >= chartArea.top && y <= chartArea.bottom) {
                                    if (isIngresoNeto) {
                                        const radius = 4;
                                        ctx.fillStyle = (options && options.bgColor) || '#F3F4F6';
                                        ctx.beginPath();
                                        ctx.moveTo(rectX + radius, rectY);
                                        ctx.arcTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + rectHeight, radius);
                                        ctx.arcTo(rectX + rectWidth, rectY + rectHeight, rectX, rectY + rectHeight, radius);
                                        ctx.arcTo(rectX, rectY + rectHeight, rectX, rectY, radius);
                                        ctx.arcTo(rectX, rectY, rectX + rectWidth, rectY, radius);
                                        ctx.closePath();
                                        ctx.fill();

                                        ctx.fillStyle = (options && options.color) || '#111827';
                                        drawFormattedText(ctx, text, x, y, fontSize, false);
                                    } else {
                                        ctx.fillStyle = (options && options.color) || '#374151';
                                        drawFormattedText(ctx, text, x, y, fontSize, false);
                                    }
                                }
                            }
                        });
                    });

                    // ---------- LINEAS: etiquetas encima de cada punto (negrita)
                    const lineDatasetIndices = chart.data.datasets.map((d, i) => {
                        const m = chart.getDatasetMeta(i);
                        return (m && m.type === 'line' && chart.isDatasetVisible(i)) ? i : -1;
                    }).filter(i => i >= 0);

                    chart.data.datasets.forEach((dataset, datasetIndex) => {
                        const meta = chart.getDatasetMeta(datasetIndex);
                        if (!meta || meta.type !== 'line' || !chart.isDatasetVisible(datasetIndex)) return;

                        // position among visible lines (for stacking if multiple)
                        const positionOffset = lineDatasetIndices.indexOf(datasetIndex);
                        const lineFontSize = (options && options.lineFontSize) || (options && options.fontSize) || 12;
                        const lineFontFamily = (options && options.lineFontFamily) || (options && options.fontFamily) || 'Arial';
                        ctx.font = 'bold ' + lineFontSize + 'px ' + lineFontFamily;
                        // Mostrar etiquetas de línea. Por defecto a la derecha; para chart1 las colocamos arriba
                        meta.data.forEach((point, index) => {
                            if (!point || point.skip) return;
                            const x = point.x;
                            const yPoint = point.y;
                            const offset = (options && options.lineOffset) || 6;

                            let text = dataset.data[index];
                            if (typeof text === 'number') {
                                if (dataset.yAxisID === 'y1' || dataset.xAxisID === 'x1') {
                                    text = new Intl.NumberFormat('es-PE', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(text) + '%';
                                } else {
                                    text = new Intl.NumberFormat('es-PE').format(text);
                                }
                            }

                            // if multiple line datasets, stack upward (vertical shift)
                            const stackSpacing = lineFontSize + 4;
                            const isChart1 = chart && chart.canvas && (chart.canvas.id === 'chart1' || chart.canvas.id === 'chartClientes' || chart.canvas.id === 'chartClientesHOD' || chart.canvas.id === 'chartClienteModal');

                            if (isChart1) {
                                // Etiqueta centrada arriba del punto
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'bottom';
                                const y = yPoint - offset - (positionOffset * stackSpacing);
                                const xLabel = x;
                                if (xLabel >= chartArea.left && xLabel <= chartArea.right && y >= chartArea.top && y <= chartArea.bottom) {
                                    ctx.fillStyle = (options && options.lineColor) || '#ef4444';
                                    drawFormattedText(ctx, text, xLabel, y, lineFontSize, false);
                                }
                            } else {
                                // Default: etiqueta a la derecha del punto
                                ctx.textAlign = 'left';
                                ctx.textBaseline = 'middle';
                                const y = yPoint - offset - (positionOffset * stackSpacing);
                                const horizOffset = (options && options.lineLabelOffsetX) ? options.lineLabelOffsetX : 8;
                                const xLabel = x + horizOffset + (positionOffset * 6);
                                if (xLabel >= chartArea.left && xLabel <= chartArea.right && y >= chartArea.top && y <= chartArea.bottom) {
                                    ctx.fillStyle = (options && options.lineColor) || '#111827';
                                    drawFormattedText(ctx, text, xLabel, y, lineFontSize, false);
                                }
                            }
                        });
                    });
                }
            };

            // Registrar plugin globalmente
            Chart.register(barBaseLabelPlugin);

            const commonOptions = {
                responsive: true,
                maintainAspectRatio: false,
                // Dejar espacio a la derecha para etiquetas dibujadas fuera del canvas
                layout: { padding: { right: 64 } },
                plugins: { 
                    legend: { 
                        position: 'bottom'
                    } 
                },
                scales: {
                    x: { ticks: { color: '#374151', font: { weight: 'bold' } } },
                    y: { beginAtZero: true, ticks: { color: '#374151', font: { weight: 'bold' } } }
                }
            };

            // Chart 1: Mixto
            const ctx1 = document.getElementById('chart1').getContext('2d');
            charts.c1 = new Chart(ctx1, {
                type: 'bar',
                data: {
                    labels: [],
                        datasets: [
                        { label: 'Ingreso Neto', data: [], backgroundColor: '#3b82f6', order: 2, yAxisID: 'y' },
                        { label: 'Diferencia', data: [], backgroundColor: '#f97316', order: 2, yAxisID: 'y' },
                        { label: '% Dif', data: [], type: 'line', borderColor: '#ef4444', backgroundColor: '#ef4444', pointBackgroundColor: '#ef4444', pointBorderColor: '#ef4444', yAxisID: 'y1', order: 1 }
                    ]
                },
                options: {
                    ...commonOptions,
                    // Reducir padding derecho para que el chart ocupe más ancho
                    layout: { padding: { right: 16 } },
                        plugins: {
                            ...commonOptions.plugins,
                            // ocultar la leyenda nativa porque usamos una leyenda DOM a la derecha del título
                            legend: { display: false },
                            // Opciones para el plugin de etiquetas en la base de las barras
                            barBaseLabels: {
                                color: '#374151',
                                fontSize: 14,
                                fontFamily: 'Helvetica Neue, Arial',
                                padding: 1,
                                lineColor: '#ef4444',
                                lineOffset: 6
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) label += ': ';
                                        if (context.dataset.yAxisID === 'y1') {
                                            label += new Intl.NumberFormat('es-PE', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(context.parsed.y) + '%';
                                        } else {
                                            label += new Intl.NumberFormat('es-PE').format(context.parsed.y);
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                    scales: {
                        x: { ticks: { color: '#374151', font: { weight: 'bold' } } },
                        y: { 
                            position: 'left',
                            ticks: { callback: val => formatShortNumber(val), color: '#374151', font: { weight: 'bold' } }
                        },
                        y1: { 
                            // Ocultamos el eje secundario para dar más espacio horizontal al chart
                            display: false,
                            grid: { display: false }
                        }
                    }
                }
            });

            // Chart 2: Saldos 2da (Horizontal bar + line), similar to chart5
            const ctx2 = document.getElementById('chart2').getContext('2d');
            charts.c2 = new Chart(ctx2, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                            { label: 'Saldos 2da', data: [], backgroundColor: '#fdba74', borderRadius: 3, yAxisID: 'y' },
                            { label: '%Saldos 2da', data: [], type: 'line', borderColor: '#fdba74', backgroundColor: '#fdba74', pointBackgroundColor: '#fdba74', pointBorderColor: '#fdba74', xAxisID: 'x1', order: 0 }
                        ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: { right: 48 } },
                    plugins: {
                        barBaseLabels: { fontSize: 14, lineFontSize: 16, color: '#374151', fontFamily: 'Helvetica Neue, Arial', padding: 3 },
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            cornerRadius: 4,
                            titleSpacing: 4,
                            bodySpacing: 6,
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;
                                },
                                label: function(context) {
                                    // Solo mostrar Pds Despacho para la barra, nada para la línea
                                    if (context.dataset.xAxisID === 'x1') {
                                        return '';
                                    }
                                    // Para la serie de barras, mostrar solo Pds Despacho
                                    if (context.dataset.prendasDespacho) {
                                        const prendasDesp = context.dataset.prendasDespacho[context.dataIndex] || 0;
                                        return 'Pds Despacho: ' + new Intl.NumberFormat('es-PE').format(prendasDesp);
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        y: { beginAtZero: true, display: true, ticks: { color: '#374151', font: { weight: 'bold' } }, grid: { color: '#e6e6e6' } },
                        x: {
                            beginAtZero: true,
                            min: 0,
                            max: 20000,
                            ticks: { callback: val => formatShortNumber(val), color: '#374151', stepSize: 5000, font: { weight: 'bold' } },
                            grid: { color: '#e6e6e6' }
                        },
                        x1: {
                            position: 'top',
                            display: false,
                            min: -5,
                            grid: { display: false }
                        }
                    }
                }
            });

            // Chart 3: Saldos 3ra (Horizontal bar + line)
            const ctx3 = document.getElementById('chart3').getContext('2d');
            charts.c3 = new Chart(ctx3, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'Saldos 3ra', data: [], backgroundColor: '#fecaca', borderRadius: 3, yAxisID: 'y' },
                        { label: '%Saldos 3ra', data: [], type: 'line', borderColor: '#fecaca', backgroundColor: '#fecaca', pointBackgroundColor: '#fecaca', pointBorderColor: '#fecaca', xAxisID: 'x1', order: 0 }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: { right: 48 } },
                    plugins: {
                        barBaseLabels: { fontSize: 14, lineFontSize: 16, color: '#374151', fontFamily: 'Helvetica Neue, Arial', padding: 3 },
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            cornerRadius: 4,
                            titleSpacing: 4,
                            bodySpacing: 6,
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;
                                },
                                label: function(context) {
                                    // Solo mostrar Pds Despacho para la barra, nada para la línea
                                    if (context.dataset.xAxisID === 'x1') {
                                        return '';
                                    }
                                    // Para la serie de barras, mostrar solo Pds Despacho
                                    if (context.dataset.prendasDespacho) {
                                        const prendasDesp = context.dataset.prendasDespacho[context.dataIndex] || 0;
                                        return 'Pds Despacho: ' + new Intl.NumberFormat('es-PE').format(prendasDesp);
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        y: { beginAtZero: true, display: true, ticks: { color: '#374151', font: { weight: 'bold' } }, grid: { color: '#e6e6e6' } },
                        x: {
                            beginAtZero: true,
                            min: 0,
                            max: 20000,
                            ticks: { callback: val => formatShortNumber(val), color: '#374151', stepSize: 5000, font: { weight: 'bold' } },
                            grid: { color: '#e6e6e6' }
                        },
                        x1: {
                            position: 'top',
                            display: false,
                            grid: { display: false }
                        }
                    }
                }
            });

            // Chart Clientes: Análisis por Cliente (barras + línea)
            const ctxClientes = document.getElementById('chartClientes').getContext('2d');
            charts.clientes = new Chart(ctxClientes, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'Prendas Ingreso Neto', data: [], backgroundColor: '#7dd3fc', yAxisID: 'y', order: 2 },
                        { label: '%Saldo 1ra', data: [], type: 'line', borderColor: '#ef4444', backgroundColor: '#ef4444', pointBackgroundColor: '#ef4444', yAxisID: 'y1', order: 1 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: { right: 8 } },
                    plugins: {
                        legend: { position: 'bottom' },
                        barBaseLabels: {
                            color: '#374151',
                            fontSize: 16,
                            fontFamily: 'Helvetica Neue, Arial',
                            padding: 3,
                            lineColor: '#ef4444',
                            lineOffset: 10
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return context[0].label || '';
                                },
                                label: function(context) {
                                    const datasetIndex = context.datasetIndex;
                                    const dataIndex = context.dataIndex;
                                    
                                    // Para la serie de barras (Prendas Ingreso Neto)
                                    if (datasetIndex === 0) {
                                        const prendasDesp = context.dataset.prendasDespacho ? context.dataset.prendasDespacho[dataIndex] : 0;
                                        const prendasPedido = context.dataset.prendasPedido ? context.dataset.prendasPedido[dataIndex] : 0;
                                        const porcDesp = prendasPedido ? (prendasDesp / prendasPedido) * 100 : 0;
                                        
                                        return [
                                            'Pds desp.: ' + new Intl.NumberFormat('es-PE').format(prendasDesp),
                                            '%Desp.: ' + new Intl.NumberFormat('es-PE', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(porcDesp) + '%'
                                        ];
                                    }
                                    
                                    // Para la línea
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            position: 'left',
                            beginAtZero: true,
                            ticks: { callback: val => formatShortNumber(val), font: { weight: 'bold' } }
                        },
                        y1: {
                            position: 'right',
                            display: false,
                            beginAtZero: true,
                            min: -5,
                            grid: { display: false },
                            ticks: {
                                callback: function(val) {
                                    return val.toFixed(2) + '%';
                                }
                            }
                        }
                    }
                }
            });

            // Chart Clientes 2da: Análisis por Cliente (barras + línea) para Saldos 2da
            const ctxClientes2da = document.getElementById('chartClientes2da').getContext('2d');
            charts.clientes2da = new Chart(ctxClientes2da, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'Prendas Ingreso Neto', data: [], backgroundColor: '#7dd3fc', yAxisID: 'y', order: 2 },
                        { label: '%Saldo 2da', data: [], type: 'line', borderColor: '#f59e0b', backgroundColor: '#f59e0b', pointBackgroundColor: '#f59e0b', yAxisID: 'y1', order: 1 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: { right: 8 } },
                    plugins: {
                        legend: { position: 'bottom' },
                        barBaseLabels: {
                            color: '#374151',
                            fontSize: 16,
                            fontFamily: 'Helvetica Neue, Arial',
                            padding: 3,
                            lineColor: '#f59e0b',
                            lineOffset: 10
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return context[0].label || '';
                                },
                                label: function(context) {
                                    const datasetIndex = context.datasetIndex;
                                    const dataIndex = context.dataIndex;
                                    
                                    // Para la serie de barras (Prendas Ingreso Neto)
                                    if (datasetIndex === 0) {
                                        const prendasDesp = context.dataset.prendasDespacho ? context.dataset.prendasDespacho[dataIndex] : 0;
                                        const prendasPedido = context.dataset.prendasPedido ? context.dataset.prendasPedido[dataIndex] : 0;
                                        const porcDesp = prendasPedido ? (prendasDesp / prendasPedido) * 100 : 0;
                                        
                                        return [
                                            'Pds desp.: ' + new Intl.NumberFormat('es-PE').format(prendasDesp),
                                            '%Desp.: ' + new Intl.NumberFormat('es-PE', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(porcDesp) + '%'
                                        ];
                                    }
                                    
                                    // Para la línea
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            position: 'left',
                            beginAtZero: true,
                            ticks: { callback: val => formatShortNumber(val), font: { weight: 'bold' } }
                        },
                        y1: {
                            position: 'right',
                            display: false,
                            beginAtZero: true,
                            min: -5,
                            grid: { display: false },
                            ticks: {
                                callback: function(val) {
                                    return val.toFixed(2) + '%';
                                }
                            }
                        }
                    }
                }
            });

            // Chart Clientes 3ra: Análisis por Cliente (barras + línea) para Saldos 3ra
            const ctxClientes3ra = document.getElementById('chartClientes3ra').getContext('2d');
            charts.clientes3ra = new Chart(ctxClientes3ra, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'Prendas Ingreso Neto', data: [], backgroundColor: '#7dd3fc', yAxisID: 'y', order: 2 },
                        { label: '%Saldo 3ra', data: [], type: 'line', borderColor: '#10b981', backgroundColor: '#10b981', pointBackgroundColor: '#10b981', yAxisID: 'y1', order: 1 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: { right: 8 } },
                    plugins: {
                        legend: { position: 'bottom' },
                        barBaseLabels: {
                            color: '#374151',
                            fontSize: 16,
                            fontFamily: 'Helvetica Neue, Arial',
                            padding: 3,
                            lineColor: '#10b981',
                            lineOffset: 10
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return context[0].label || '';
                                },
                                label: function(context) {
                                    const datasetIndex = context.datasetIndex;
                                    const dataIndex = context.dataIndex;
                                    
                                    // Para la serie de barras (Prendas Ingreso Neto)
                                    if (datasetIndex === 0) {
                                        const prendasDesp = context.dataset.prendasDespacho ? context.dataset.prendasDespacho[dataIndex] : 0;
                                        const prendasPedido = context.dataset.prendasPedido ? context.dataset.prendasPedido[dataIndex] : 0;
                                        const porcDesp = prendasPedido ? (prendasDesp / prendasPedido) * 100 : 0;
                                        
                                        return [
                                            'Pds desp.: ' + new Intl.NumberFormat('es-PE').format(prendasDesp),
                                            '%Desp.: ' + new Intl.NumberFormat('es-PE', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(porcDesp) + '%'
                                        ];
                                    }
                                    
                                    // Para la línea
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            position: 'left',
                            beginAtZero: true,
                            ticks: { callback: val => formatShortNumber(val), font: { weight: 'bold' } }
                        },
                        y1: {
                            position: 'right',
                            display: false,
                            beginAtZero: true,
                            min: -5,
                            grid: { display: false },
                            ticks: {
                                callback: function(val) {
                                    return val.toFixed(2) + '%';
                                }
                            }
                        }
                    }
                }
            });

            // Chart Clientes HOD: Análisis por Cliente (barras + línea)
            const ctxClientesHOD = document.getElementById('chartClientesHOD').getContext('2d');
            charts.clientesHOD = new Chart(ctxClientesHOD, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'Pds desp.', data: [], backgroundColor: '#7dd3fc', yAxisID: 'y', order: 2 },
                        { label: '%Saldo 1ra', data: [], type: 'line', borderColor: '#ef4444', backgroundColor: '#ef4444', pointBackgroundColor: '#ef4444', yAxisID: 'y1', order: 1 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: { right: 8 } },
                    plugins: {
                        legend: { position: 'bottom' },
                        barBaseLabels: {
                            color: '#374151',
                            fontSize: 16,
                            fontFamily: 'Helvetica Neue, Arial',
                            padding: 3,
                            lineColor: '#ef4444',
                            lineOffset: 10
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return context[0].label || '';
                                },
                                label: function(context) {
                                    const datasetIndex = context.datasetIndex;
                                    const dataIndex = context.dataIndex;
                                    
                                    // Para la serie de barras (Pds desp.)
                                    if (datasetIndex === 0) {
                                        const prendasDesp = context.dataset.prendasDespacho ? context.dataset.prendasDespacho[dataIndex] : 0;
                                        const porcDesp = context.dataset.porcDesp ? context.dataset.porcDesp[dataIndex] : 0;
                                        
                                        return [
                                            'Pds desp.: ' + new Intl.NumberFormat('es-PE').format(prendasDesp),
                                            '%Desp.: ' + new Intl.NumberFormat('es-PE', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(porcDesp) + '%'
                                        ];
                                    }
                                    
                                    // Para la línea
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            position: 'left',
                            beginAtZero: true,
                            ticks: { callback: val => formatShortNumber(val), font: { weight: 'bold' } }
                        },
                        y1: {
                            position: 'right',
                            display: false,
                            beginAtZero: true,
                            min: -5,
                            grid: { display: false },
                            ticks: {
                                callback: function(val) {
                                    return val.toFixed(2) + '%';
                                }
                            }
                        }
                    }
                }
            });

            // Chart Modal Cliente: Ingreso Neto vs Diferencia por Cliente
            const ctxClienteModal = document.getElementById('chartClienteModal').getContext('2d');
            charts.clienteModal = new Chart(ctxClienteModal, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'Ingreso Neto', data: [], backgroundColor: '#3b82f6', order: 2, yAxisID: 'y', pointStyle: 'circle' },
                        { label: 'Diferencia', data: [], backgroundColor: '#f97316', order: 2, yAxisID: 'y', pointStyle: 'circle' },
                        { label: '% Dif', data: [], type: 'line', borderColor: '#ef4444', backgroundColor: '#ef4444', pointBackgroundColor: '#ef4444', pointBorderColor: '#ef4444', yAxisID: 'y1', order: 1, tension: 0.1, pointStyle: 'circle' }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: { right: 16 } },
                    plugins: {
                        legend: { 
                            position: 'top',
                            align: 'end',
                            usePointStyle: true,
                            pointStyle: 'circle'
                        },
                        barBaseLabels: {
                            color: '#374151',
                            fontSize: 18,
                            fontFamily: 'Helvetica Neue, Arial',
                            padding: 1,
                            lineColor: '#ef4444',
                            lineOffset: 6,
                            lineFontSize: 16
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.dataset.yAxisID === 'y1') {
                                        label += new Intl.NumberFormat('es-PE', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(context.parsed.y) + '%';
                                    } else {
                                        label += new Intl.NumberFormat('es-PE').format(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { ticks: { color: '#374151', font: { weight: 'bold', size: 14 } } },
                        y: { 
                            position: 'left',
                            ticks: { callback: val => formatShortNumber(val), color: '#374151', font: { weight: 'bold', size: 14 } }
                        },
                        y1: { 
                            position: 'right',
                            display: false,
                            grid: { display: false },
                            ticks: {
                                callback: function(val) {
                                    return val.toFixed(2) + '%';
                                },
                                color: '#ef4444',
                                font: { weight: 'bold', size: 14 }
                            }
                        }
                    }
                }
            });

            // Chart 5: Saldos 1ra (Horizontal bar + line)
            const ctx5 = document.getElementById('chart5').getContext('2d');
            charts.c5 = new Chart(ctx5, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'Saldos 1ra', data: [], backgroundColor: '#93c5fd', borderRadius: 3, yAxisID: 'y' },
                        { label: '%Saldos 1ra', data: [], type: 'line', borderColor: '#93c5fd', backgroundColor: '#93c5fd', pointBackgroundColor: '#93c5fd', pointBorderColor: '#93c5fd', xAxisID: 'x1', order: 0 }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: { right: 48 } },
                    plugins: {
                        barBaseLabels: { fontSize: 14, lineFontSize: 16, color: '#374151', fontFamily: 'Helvetica Neue, Arial', padding: 3 },
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            cornerRadius: 4,
                            titleSpacing: 4,
                            bodySpacing: 6,
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;
                                },
                                label: function(context) {
                                    // Solo mostrar Pds Despacho para la barra, nada para la línea
                                    if (context.dataset.xAxisID === 'x1') {
                                        return '';
                                    }
                                    // Para la serie de barras, mostrar solo Pds Despacho
                                    if (context.dataset.prendasDespacho) {
                                        const prendasDesp = context.dataset.prendasDespacho[context.dataIndex] || 0;
                                        return 'Pds Despacho: ' + new Intl.NumberFormat('es-PE').format(prendasDesp);
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        // Mostrar eje Y con etiquetas de categoría (meses)
                        y: { display: true, ticks: { color: '#374151' } },
                        x: { beginAtZero: true, min:0, max:20000, ticks: { callback: val => formatShortNumber(val), color: '#374151', stepSize: 5000, font: { weight: 'bold' } }, grid: { color: '#e6e6e6' } },
                        x1: { position: 'top', display: false, min: -7, grid: { display: false } }
                    }
                }
            });
        }

        async function actualizarGraficos(silentMode = false) {
            const loading = document.getElementById('mainLoader');
            if (!silentMode) {
                loading.classList.remove('hidden');
                setConnectionStatus('loading', 'Actualizando...');
            }

            // Actualizar título del gráfico 1 según filtros seleccionados
            try { actualizarTituloChart1(); actualizarTituloEvolucion(); } catch(e) { console.warn('Error actualizando títulos', e); }

            try {
                // Usar datos ya cargados en memoria (mucho más rápido)
                procesarDatosOptimizado();
                setConnectionStatus('success', 'Conectado');
            } catch (error) {
                console.error("Error procesando gráficos:", error);
                setConnectionStatus('error', 'Error procesando datos');
            } finally {
                if (!silentMode) loading.classList.add('hidden');
            }
        }

        function procesarDatosOptimizado() {
            if (!rawDataResumen || rawDataResumen.length <= 1) {
                console.warn('No hay datos para procesar');
                return;
            }
            
            // Obtener rango de fechas seleccionado
            const desdeAnio = parseInt(document.getElementById('desdeAnio').value);
            const hastaAnio = parseInt(document.getElementById('hastaAnio').value);
            const desdeMes = parseInt(document.getElementById('desdeMes').value);
            const hastaMes = parseInt(document.getElementById('hastaMes').value);
            
            // Encontrar índices de columnas
            const headers = rawDataResumen[0];
            const colAnio = headers.findIndex(h => h && h.toString().toLowerCase().includes('año'));
            const colMes = headers.findIndex(h => h && h.toString().toLowerCase() === 'mes');
            const colIngreso = headers.findIndex(h => h && h.toString().toLowerCase().includes('ingreso'));
            const colDiferencia = headers.findIndex(h => h && h.toString().toLowerCase().includes('dif'));
            const colPorcentaje = headers.findIndex(h => h && h.toString().toLowerCase().includes('%'));
            
            if (colAnio === -1 || colMes === -1) {
                console.error('Columnas necesarias no encontradas');
                return;
            }
            
            // Filtrar datos según rango
            const monthsOrder = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Set", "Oct", "Nov", "Dic"];
            const dataFiltrada = [];
            
            // Crear fechas numéricas para comparación (año * 12 + mes)
            const fechaDesde = desdeAnio * 12 + desdeMes;
            const fechaHasta = hastaAnio * 12 + hastaMes;
            
            // Si las fechas están invertidas, intercambiarlas
            const fechaMin = Math.min(fechaDesde, fechaHasta);
            const fechaMax = Math.max(fechaDesde, fechaHasta);
            
            for (let i = 1; i < rawDataResumen.length; i++) {
                const row = rawDataResumen[i];
                const anio = parseInt(row[colAnio]) || 0;
                const mesTxt = (row[colMes] || '').toString().trim();
                const mesIdx = monthsOrder.indexOf(mesTxt);
                
                if (mesIdx === -1) continue;
                
                // Crear fecha numérica del registro para comparación
                const fechaRegistro = anio * 12 + mesIdx;
                
                // Filtrar por rango usando comparación numérica simple
                if (fechaRegistro < fechaMin || fechaRegistro > fechaMax) continue;
                
                dataFiltrada.push({
                    anio: anio,
                    mes: mesTxt,
                    mesIdx: mesIdx,
                    ingreso: parseFloat(row[colIngreso]) || 0,
                    diferencia: parseFloat(row[colDiferencia]) || 0,
                    porcentaje: parseFloat(row[colPorcentaje]) || 0
                });
            }
            
            // Calcular saldos desde rawDataBase si están disponibles
            const saldosMap = calcularSaldosDesdeBase();
            
            // Agregar saldos a los datos filtrados
            dataFiltrada.forEach(item => {
                const key = `${item.anio}|${item.mes}`;
                const saldos = saldosMap[key] || { saldos1ra: 0, saldos2da: 0, saldos3ra: 0, prendasDespacho: 0 };
                item.saldos1ra = saldos.saldos1ra;
                item.saldos2da = saldos.saldos2da;
                item.saldos3ra = saldos.saldos3ra;
                item.prendasDespacho = saldos.prendasDespacho;
            });
            
            procesarDatos(dataFiltrada);
        }
        
        function calcularSaldosDesdeBase() {
            const saldosMap = {};
            
            if (!rawDataBase || rawDataBase.length <= 1) {
                return saldosMap;
            }
            
            try {
                const headers = rawDataBase[0];
                const colAnio = 0; // Primera columna
                const colMes = 1;  // Segunda columna
                const colSaldo1 = 78; // CA (índice 78)
                const colSaldo2 = 82; // CE (índice 82)
                const colSaldo3 = 86; // CI (índice 86)
                // Buscar índice de columna "Prendas Despacho Almacen"
                const colPrendasDespacho = headers.findIndex(h => h && h.toString().toLowerCase().includes('prendas despacho almacen'));
                
                for (let i = 1; i < rawDataBase.length; i++) {
                    const row = rawDataBase[i];
                    if (!row || row.length < 87) continue;
                    
                    const anio = row[colAnio];
                    const mes = row[colMes];
                    const key = `${anio}|${mes}`;
                    
                    if (!saldosMap[key]) {
                        saldosMap[key] = { saldos1ra: 0, saldos2da: 0, saldos3ra: 0, prendasDespacho: 0 };
                    }
                    
                    saldosMap[key].saldos1ra += parseFloat(row[colSaldo1]) || 0;
                    saldosMap[key].saldos2da += parseFloat(row[colSaldo2]) || 0;
                    saldosMap[key].saldos3ra += parseFloat(row[colSaldo3]) || 0;
                    if (colPrendasDespacho !== -1) {
                        saldosMap[key].prendasDespacho += parseFloat(row[colPrendasDespacho]) || 0;
                    }
                }
            } catch (error) {
                console.warn('Error calculando saldos:', error);
            }
            
            return saldosMap;
        }
        
        function procesarDatos(data) {
            if (!data || data.length === 0) {
                // Limpiar gráficos
                [charts.c1, charts.c2, charts.c5, charts.c3].forEach(c => {
                    if (c) {
                        c.data.labels = [];
                        c.data.datasets.forEach(d => d.data = []);
                    }
                });
                return;
            }

            // Preparar arrays
            const labels = [];
            const dataIngreso = [];
            const dataDiferencia = [];
            const dataPorcentaje = [];
            const dataSaldos1ra = [];
            const dataPorcSaldos1ra = [];
            const dataSaldos2da = [];
            const dataPorcSaldos2da = [];
            const dataSaldos3ra = [];
            const dataPorcSaldos3ra = [];
            const dataPrendasDespacho1ra = [];
            const dataPrendasDespacho2da = [];
            const dataPrendasDespacho3ra = [];

            // Procesar datos una sola vez
            data.forEach(item => {
                labels.push(`${item.mes} ${item.anio}`);
                
                const ing = parseFloat(item.ingreso) || 0;
                const dif = parseFloat(item.diferencia) || 0;
                const saldos1ra = parseFloat(item.saldos1ra) || 0;
                const saldos2da = parseFloat(item.saldos2da) || 0;
                const saldos3ra = parseFloat(item.saldos3ra) || 0;
                const prendasDespacho = parseFloat(item.prendasDespacho) || 0;
                const porc = (parseFloat(item.porcentaje) || 0) * 100;
                
                dataIngreso.push(ing);
                dataDiferencia.push(dif);
                dataSaldos1ra.push(saldos1ra);
                dataSaldos2da.push(saldos2da);
                dataSaldos3ra.push(saldos3ra);
                dataPorcentaje.push(Number(porc.toFixed(2)));
                dataPrendasDespacho1ra.push(prendasDespacho);
                dataPrendasDespacho2da.push(prendasDespacho);
                dataPrendasDespacho3ra.push(prendasDespacho);

                // Cálculos de porcentajes
                dataPorcSaldos1ra.push(ing !== 0 ? Number(((saldos1ra / ing) * 100).toFixed(2)) : 0);
                dataPorcSaldos2da.push(ing !== 0 ? Number(((saldos2da / ing) * 100).toFixed(2)) : 0);
                dataPorcSaldos3ra.push(ing !== 0 ? Number(((saldos3ra / ing) * 100).toFixed(2)) : 0);
            });

            // Actualizar todos los gráficos en batch
            requestAnimationFrame(() => {
                // Gráfico 1
                charts.c1.data.labels = labels;
                charts.c1.data.datasets[0].data = dataIngreso;
                charts.c1.data.datasets[1].data = dataDiferencia;
                charts.c1.data.datasets[2].data = dataPorcentaje;
                ajustarEjeY1(charts.c1, dataPorcentaje, -0.3);

                // Gráfico 2
                charts.c2.data.labels = labels;
                charts.c2.data.datasets[0].data = dataSaldos2da;
                charts.c2.data.datasets[0].prendasDespacho = dataPrendasDespacho2da;
                charts.c2.data.datasets[1].data = dataPorcSaldos2da;
                ajustarEjeX1(charts.c2, dataPorcSaldos2da, -0.3);

                // Gráfico 3
                if (charts.c3) {
                    charts.c3.data.labels = labels;
                    charts.c3.data.datasets[0].data = dataSaldos3ra;
                    charts.c3.data.datasets[0].prendasDespacho = dataPrendasDespacho3ra;
                    charts.c3.data.datasets[1].data = dataPorcSaldos3ra;
                    ajustarEjeX1(charts.c3, dataPorcSaldos3ra, -5);
                }

                // Gráfico 5
                charts.c5.data.labels = labels;
                charts.c5.data.datasets[0].data = dataSaldos1ra;
                charts.c5.data.datasets[0].prendasDespacho = dataPrendasDespacho1ra;
                charts.c5.data.datasets[1].data = dataPorcSaldos1ra;
                ajustarEjeX1(charts.c5, dataPorcSaldos1ra, -7);

                // Actualizar todos los gráficos una sola vez
                charts.c1.update('none'); // 'none' evita animaciones para mayor velocidad
                charts.c2.update('none');
                if (charts.c3) charts.c3.update('none');
                charts.c5.update('none');
                
                // Actualizar leyenda
                try { renderChart1Legend(); } catch(e) { console.warn('Error renderizando leyenda', e); }
            });
        }
        
        // Helper para ajustar eje Y secundario
        function ajustarEjeY1(chart, data, minVal) {
            try {
                const maxPorc = data.length ? Math.max(...data.map(v => Number(v) || 0)) : 0;
                const suggestedMax = maxPorc > 0 ? maxPorc * 1.25 : 1;
                if (!chart.options.scales.y1) chart.options.scales.y1 = {};
                chart.options.scales.y1.max = Math.round(suggestedMax * 100) / 100;
                chart.options.scales.y1.min = minVal;
            } catch (e) {
                console.warn('Error ajustando eje y1', e);
            }
        }
        
        // Helper para ajustar eje X secundario (gráficos horizontales)
        function ajustarEjeX1(chart, data, minVal) {
            try {
                const maxPorc = data.length ? Math.max(...data.map(v => Number(v) || 0)) : 0;
                const suggestedMax = maxPorc > 0 ? maxPorc * 1.25 : 1;
                if (!chart.options.scales.x1) chart.options.scales.x1 = {};
                chart.options.scales.x1.max = Math.round(suggestedMax * 100) / 100;
                chart.options.scales.x1.min = minVal;
                if (!chart.options.scales.x) chart.options.scales.x = {};
                chart.options.scales.x.max = 20000;
                chart.options.scales.x.min = 0;
            } catch (e) {
                console.warn('Error ajustando eje x1', e);
            }
        }

        async function cargarDatosClientes() {
            // Verificar si tenemos datos en caché válidos
            const now = Date.now();
            if (cache.clientes && cache.timestamp && (now - cache.timestamp) < cache.TTL) {
                actualizarTablaClientes(cache.clientes);
                actualizarGraficoClientes(cache.clientes);
                actualizarTablaClientes2da(cache.clientes);
                actualizarGraficoClientes2da(cache.clientes);
                actualizarTablaClientes3ra(cache.clientes);
                actualizarGraficoClientes3ra(cache.clientes);
                actualizarTablaClientesHOD(cache.clientes);
                actualizarGraficoClientesHOD(cache.clientes);
                return;
            }
            
            return new Promise((resolve, reject) => {
                try {
                    // Crear un callback único para esta carga
                    const callbackName = 'loadClientesCallback_' + Date.now();
                    
                    // Definir el callback globalmente
                    window[callbackName] = function(jsonResponse) {
                        try {
                            if (!jsonResponse || !jsonResponse.table) {
                                throw new Error("Respuesta inválida desde Google Visualization API");
                            }
                            
                            const cols = jsonResponse.table.cols.map(col => col.label || col.id || '');
                            const rows = jsonResponse.table.rows.map(r => r.c.map(cell => (cell && cell.v !== null) ? cell.v : ""));
                            
                            // Encontrar índices de columnas
                            const anioIdx = cols.findIndex(c => c && c.toLowerCase().includes('año'));
                            const mesIdx = cols.findIndex(c => c && c.toLowerCase().includes('mes'));
                            const clienteIdx = 3; // Columna D
                            const prendasPedidoIdx = 11; // Columna L
                            const prendasIngresoNetoIdx = 52; // Columna BA
                            const saldos1raIdx = 78; // Columna CA
                            const saldos2daIdx = 82; // Columna CE
                            const saldos3raIdx = 86; // Columna CI
                            const prendasDespachoIdx = cols.findIndex(c => c && c.toLowerCase().includes('prendas despacho almacen'));
                            const tipoOpIdx = cols.findIndex(c => {
                                const h = String(c || '').toLowerCase();
                                return (h.includes('tipo') && (h.includes('op') || h.includes('o.p') || h.includes('orden'))) || h === 'tipo op';
                            });
                            
                            if (anioIdx === -1 || mesIdx === -1) {
                                throw new Error("No se encontraron columnas de Año o Mes");
                            }
                            
                            // Encontrar el último año y mes disponible
                            let ultimoAnio = null;
                            let ultimoMes = null;
                            const monthNames = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Set", "Oct", "Nov", "Dic"];
                            
                            rows.forEach(row => {
                                const anio = row[anioIdx];
                                const mes = row[mesIdx];
                                
                                if (anio && mes) {
                                    if (ultimoAnio === null || anio > ultimoAnio) {
                                        ultimoAnio = anio;
                                        ultimoMes = mes;
                                    } else if (anio === ultimoAnio) {
                                        const mesIdx_val = monthNames.indexOf(String(mes));
                                        const ultimoMesIdx_val = monthNames.indexOf(String(ultimoMes));
                                        if (mesIdx_val > ultimoMesIdx_val) {
                                            ultimoMes = mes;
                                        }
                                    }
                                }
                            });
                            
                            if (!ultimoAnio || !ultimoMes) {
                                throw new Error("No se encontró datos de año/mes");
                            }
                            
                            // Agrupar datos del último mes por cliente
                            const clienteMap = {};
                            
                            rows.forEach(row => {
                                const anio = row[anioIdx];
                                const mes = row[mesIdx];
                                
                                if (anio === ultimoAnio && mes === ultimoMes) {
                                    const cliente = row[clienteIdx] || 'Sin cliente';
                                    const prendasPedido = parseFloat(row[prendasPedidoIdx]) || 0;
                                    const prendasIngresoNeto = parseFloat(row[prendasIngresoNetoIdx]) || 0;
                                    const saldos1ra = parseFloat(row[saldos1raIdx]) || 0;
                                    const saldos2da = parseFloat(row[saldos2daIdx]) || 0;
                                    const saldos3ra = parseFloat(row[saldos3raIdx]) || 0;
                                    const prendasDespacho = prendasDespachoIdx !== -1 ? (parseFloat(row[prendasDespachoIdx]) || 0) : 0;
                                    const tipoOp = tipoOpIdx !== -1 ? (row[tipoOpIdx] || '') : '';
                                    
                                    const key = cliente + '|' + (tipoOp || '');
                                    if (!clienteMap[key]) {
                                        clienteMap[key] = {
                                            cliente: cliente,
                                            tipoOp: tipoOp,
                                            prendasPedido: 0,
                                            prendasIngresoNeto: 0,
                                            saldos1ra: 0,
                                            saldos2da: 0,
                                            saldos3ra: 0,
                                            prendasDespacho: 0,
                                            anio: ultimoAnio,
                                            mes: ultimoMes
                                        };
                                    }
                                    
                                    clienteMap[key].prendasPedido += prendasPedido;
                                    clienteMap[key].prendasIngresoNeto += prendasIngresoNeto;
                                    clienteMap[key].saldos1ra += saldos1ra;
                                    clienteMap[key].saldos2da += saldos2da;
                                    clienteMap[key].saldos3ra += saldos3ra;
                                    clienteMap[key].prendasDespacho += prendasDespacho;
                                }
                            });
                            
                            // Convertir map a array y calcular porcentajes
                            let clienteData = Object.values(clienteMap).map(row => {
                                row.porcentajeSaldo1ra = row.prendasIngresoNeto ? (row.saldos1ra / row.prendasIngresoNeto) * 100 : 0;
                                row.porcentajeSaldo2da = row.prendasIngresoNeto ? (row.saldos2da / row.prendasIngresoNeto) * 100 : 0;
                                row.porcentajeSaldo3ra = row.prendasIngresoNeto ? (row.saldos3ra / row.prendasIngresoNeto) * 100 : 0;
                                return row;
                            });
                            
                            if (clienteData.length === 0) {
                                throw new Error("No hay datos para el último mes");
                            }
                            
                            // Ordenar por %Saldo 1ra descendente
                            clienteData.sort((a, b) => (b.porcentajeSaldo1ra || 0) - (a.porcentajeSaldo1ra || 0));
                            
                            // Guardar en caché
                            cache.clientes = clienteData;
                            cache.timestamp = now;
                            
                            actualizarTablaClientes(clienteData);
                            actualizarGraficoClientes(clienteData);
                            actualizarTablaClientes2da(clienteData);
                            actualizarGraficoClientes2da(clienteData);
                            actualizarTablaClientes3ra(clienteData);
                            actualizarGraficoClientes3ra(clienteData);
                            actualizarTablaClientesHOD(clienteData);
                            actualizarGraficoClientesHOD(clienteData);
                            
                            // Limpiar callback
                            delete window[callbackName];
                            resolve();
                        } catch (err) {
                            console.error('Error procesando datos de clientes:', err);
                            // Limpiar callback
                            delete window[callbackName];
                            reject(err);
                        }
                    };
                    
                    // Crear script para cargar datos de la hoja 'base'
                    const script = document.createElement('script');
                    script.src = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?sheet=base&tqx=responseHandler:${callbackName}`;
                    script.onerror = () => {
                        console.error('Error cargando datos desde Google Visualization API');
                        delete window[callbackName];
                        reject(new Error('Network error loading cliente data'));
                    };
                    
                    // Timeout de 15 segundos
                    const timeoutId = setTimeout(() => {
                        if (window[callbackName]) {
                            console.error('Timeout cargando datos de clientes');
                            delete window[callbackName];
                            reject(new Error('Timeout loading cliente data'));
                        }
                    }, 15000);
                    
                    window[callbackName]._timeoutId = timeoutId;
                    
                    document.body.appendChild(script);
                } catch (err) {
                    console.error('Error iniciando carga de clientes:', err);
                    reject(err);
                }
            });
        }

        function actualizarTablaClientes(data) {
            const tbody = document.getElementById('tablaClientesBody');
            const periodo = document.getElementById('clientePeriodo');
            
            if (!data || data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">No hay datos disponibles</td></tr>';
                periodo.textContent = '';
                return;
            }

            // Mostrar periodo en el encabezado
            if (data[0].anio && data[0].mes) {
                periodo.textContent = `Gráfico producción (no muestras) - ${data[0].mes} ${data[0].anio}`;
            }

            // Calcular totales
            const totals = data.reduce((acc, row) => {
                acc.prendasPedido += Number(row.prendasPedido) || 0;
                acc.prendasIngresoNeto += Number(row.prendasIngresoNeto) || 0;
                acc.saldos1ra += Number(row.saldos1ra) || 0;
                return acc;
            }, { prendasPedido: 0, prendasIngresoNeto: 0, saldos1ra: 0 });

            const totalPorc = totals.prendasIngresoNeto ? (totals.saldos1ra / totals.prendasIngresoNeto) * 100 : 0;

            // Generar filas usando DocumentFragment para mejor rendimiento
            const fragment = document.createDocumentFragment();
            const formatter = new Intl.NumberFormat('es-PE');
            
            data.forEach(row => {
                const tr = document.createElement('tr');
                tr.className = 'border-b hover:bg-gray-50';
                const porcSaldo = row.porcentajeSaldo1ra || 0;
                
                tr.innerHTML = `
                    <td class="py-2 px-2">${row.cliente || ''}</td>
                    <td class="py-2 px-2">${row.tipoOp || ''}</td>
                    <td class="py-2 px-2 text-right">${formatter.format(row.prendasPedido || 0)}</td>
                    <td class="py-2 px-2 text-right">${formatter.format(row.prendasIngresoNeto || 0)}</td>
                    <td class="py-2 px-2 text-right">${formatter.format(row.saldos1ra || 0)}</td>
                    <td class="py-2 px-2 text-right font-semibold">${porcSaldo.toFixed(2)}%</td>
                `;
                fragment.appendChild(tr);
            });

            // Fila total
            const totalTr = document.createElement('tr');
            totalTr.className = 'bg-gray-800 text-white font-bold';
            totalTr.innerHTML = `
                <td class="py-2 px-2">TOTAL</td>
                <td class="py-2 px-2">&nbsp;</td>
                <td class="py-2 px-2 text-right">${formatter.format(totals.prendasPedido)}</td>
                <td class="py-2 px-2 text-right">${formatter.format(totals.prendasIngresoNeto)}</td>
                <td class="py-2 px-2 text-right">${formatter.format(totals.saldos1ra)}</td>
                <td class="py-2 px-2 text-right">${totalPorc.toFixed(2)}%</td>
            `;
            fragment.appendChild(totalTr);

            // Actualizar DOM una sola vez
            tbody.innerHTML = '';
            tbody.appendChild(fragment);
        }

        // --- Modal handlers para detalle %Saldo 1ra por Cliente ---
        document.getElementById('tablaClientesBody').addEventListener('click', async function(e) {
            const td = e.target.closest('td');
            if (!td) return;
            const tr = td.closest('tr');
            if (!tr) return;
            // Última fila es total (tiene clase bg-gray-800 text-white), ignorarla
            if (tr.classList.contains('bg-gray-800') || tr.classList.contains('bg-gray-800')) return;

            // Determinar índice de la celda: %Saldo 1ra es la columna 5 (0-based index 5)
            const cellIndex = Array.prototype.indexOf.call(tr.children, td);
            if (cellIndex !== 5) return; // solo reaccionar en la columna %Saldo 1ra

            const cliente = (tr.children[0] && tr.children[0].textContent || '').trim();
            if (!cliente) return;

            openModalSaldo(cliente);
        });

        function closeModalSaldo() {
            const modal = document.getElementById('modalSaldo1raDetalle');
            if (modal) modal.classList.add('hidden');
        }

        document.getElementById('modalSaldoClose').addEventListener('click', closeModalSaldo);
        document.getElementById('modalSaldoOverlay').addEventListener('click', closeModalSaldo);

        // --- Modal handlers para detalle %Saldo 2da por Cliente ---
        document.getElementById('tablaClientes2daBody').addEventListener('click', async function(e) {
            const td = e.target.closest('td');
            if (!td) return;
            const tr = td.closest('tr');
            if (!tr) return;
            // Última fila es total (tiene clase bg-gray-800 text-white), ignorarla
            if (tr.classList.contains('bg-gray-800') || tr.classList.contains('bg-gray-800')) return;

            // Determinar índice de la celda: %Saldo 2da es la columna 5 (0-based index 5)
            const cellIndex = Array.prototype.indexOf.call(tr.children, td);
            if (cellIndex !== 5) return; // solo reaccionar en la columna %Saldo 2da

            const cliente = (tr.children[0] && tr.children[0].textContent || '').trim();
            if (!cliente) return;

            openModalSaldo2da(cliente);
        });

        function closeModalSaldo2da() {
            const modal = document.getElementById('modalSaldo2daDetalle');
            if (modal) modal.classList.add('hidden');
        }

        document.getElementById('modalSaldo2daClose').addEventListener('click', closeModalSaldo2da);
        document.getElementById('modalSaldo2daOverlay').addEventListener('click', closeModalSaldo2da);

        // --- Modal handlers para detalle %Saldo 3ra por Cliente ---
        document.getElementById('tablaClientes3raBody').addEventListener('click', async function(e) {
            const td = e.target.closest('td');
            if (!td) return;
            const tr = td.closest('tr');
            if (!tr) return;
            // Última fila es total (tiene clase bg-gray-800 text-white), ignorarla
            if (tr.classList.contains('bg-gray-800') || tr.classList.contains('bg-gray-800')) return;

            // Determinar índice de la celda: %Saldo 3ra es la columna 5 (0-based index 5)
            const cellIndex = Array.prototype.indexOf.call(tr.children, td);
            if (cellIndex !== 5) return; // solo reaccionar en la columna %Saldo 3ra

            const cliente = (tr.children[0] && tr.children[0].textContent || '').trim();
            if (!cliente) return;

            openModalSaldo3ra(cliente);
        });

        function closeModalSaldo3ra() {
            const modal = document.getElementById('modalSaldo3raDetalle');
            if (modal) modal.classList.add('hidden');
        }

        document.getElementById('modalSaldo3raClose').addEventListener('click', closeModalSaldo3ra);
        document.getElementById('modalSaldo3raOverlay').addEventListener('click', closeModalSaldo3ra);

        async function openModalSaldo3ra(cliente) {
            const modal = document.getElementById('modalSaldo3raDetalle');
            const title = document.getElementById('modalSaldo3raTitle');
            const body = document.getElementById('modalSaldo3raBody');
            const formatter = new Intl.NumberFormat('es-PE');

            // Calcular porcentajes desde caché de clientes si está disponible
            let tipoOp = '';
            let saldo1ra = 0, saldo2da = 0, saldo3ra = 0, porcDesp = 0;
            try {
                if (cache && cache.clientes && Array.isArray(cache.clientes)) {
                    const found = cache.clientes.find(c => (c.cliente || '').toString().trim().toLowerCase() === cliente.toString().trim().toLowerCase());
                    if (found) {
                        saldo1ra = Number(found.porcentajeSaldo1ra) || 0;
                        saldo2da = Number(found.porcentajeSaldo2da) || 0;
                        saldo3ra = Number(found.porcentajeSaldo3ra) || 0;
                        porcDesp = found.prendasPedido ? (found.prendasDespacho / found.prendasPedido) * 100 : 0;
                        tipoOp = found.tipoOp || '';
                    }
                }
            } catch (e) { console.warn('Error leyendo cache.clientes', e); }

            const totalSaldo = saldo1ra + saldo2da + saldo3ra;
            title.innerHTML = `<div>${cliente} - Tipo: ${tipoOp}</div><div class="text-sm font-normal">%Saldo: 1ra (${saldo1ra.toFixed(2)}%) + 2da (${saldo2da.toFixed(2)}%) + 3ra (${saldo3ra.toFixed(2)}%) = ${totalSaldo.toFixed(2)}% &nbsp;-&nbsp; %Desp.= ${porcDesp.toFixed(2)}%</div>`;
            body.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">Cargando...</td></tr>';
            modal.classList.remove('hidden');

            try {
                // OPTIMIZACIÓN: Usar datos ya cargados en memoria en lugar de fetch
                if (!rawDataBase || rawDataBase.length <= 1) {
                    // Si no hay datos base, intentar cargarlos primero
                    body.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">Cargando datos base...</td></tr>';
                    await cargarDatosBase();
                    // Esperar un momento para que se procesen
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                // Filtrar datos de rawDataBase por cliente
                const rows = filtrarBaseByCliente(cliente);
                
                if (!rows || rows.length === 0) {
                    body.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">No hay datos disponibles</td></tr>';
                    return;
                }

                // Ordenar por %Corte de mayor a menor
                rows.sort((a, b) => {
                    const pedidoA = Number(a.pedido) || 0;
                    const cortadasA = Number(a.cortadas) || 0;
                    const cortasA = pedidoA ? (cortadasA / pedidoA * 100) : 0;
                    
                    const pedidoB = Number(b.pedido) || 0;
                    const cortadasB = Number(b.cortadas) || 0;
                    const cortasB = pedidoB ? (cortadasB / pedidoB * 100) : 0;
                    
                    return cortasB - cortasA; // De mayor a menor
                });

                const modalFragment = document.createDocumentFragment();
                let totalPedido = 0, totalPedidoHM = 0, totalProg = 0, totalGirado = 0, totalCortadas = 0, totalDespachoAlmacen = 0, totalIngresoNeto = 0;

                rows.forEach(r => {
                    const tr = document.createElement('tr');
                    tr.className = 'border-b';
                    const estilo = r.estilo || '';
                    const pedido = Number(r.pedido) || 0;
                    const pedidoHM = Number(r.pedidoHM) || 0;
                    const prog = Number(r.prog) || 0;
                    const girado = Number(r.girado) || 0;
                    const cortadas = Number(r.cortadas) || 0;
                    const despachoAlmacen = Number(r.despachoAlmacen) || 0;
                    const ingresoNeto = Number(r.ingresoNeto) || 0;
                    const progPct = pedido ? (prog / pedido * 100) : 0;
                    const giroPct = pedido ? (girado / pedido * 100) : 0;
                    const cortasPct = pedido ? (cortadas / pedido * 100) : 0;
                    const despPct = pedido ? (despachoAlmacen / pedido * 100) : 0;
                    const ingresoPct = ingresoNeto ? (cortadas / ingresoNeto * 100) : 0;

                    totalPedido += pedido;
                    totalPedidoHM += pedidoHM;
                    totalProg += prog;
                    totalGirado += girado;
                    totalCortadas += cortadas;
                    totalDespachoAlmacen += despachoAlmacen;
                    totalIngresoNeto += ingresoNeto;

                    tr.innerHTML = `
                        <td class="py-2 px-2">${estilo}</td>
                        <td class="py-1 px-1 text-right">${formatter.format(pedido)}</td>
                        <td class="py-1 px-1 text-right hidden">${formatter.format(pedidoHM)}</td>
                        <td class="py-1 px-1 text-right">${formatter.format(prog)}</td>
                        <td class="py-1 px-1 text-right">${progPct.toFixed(2)}%</td>
                        <td class="py-1 px-1 text-right">${formatter.format(girado)}</td>
                        <td class="py-1 px-1 text-right">${giroPct.toFixed(2)}%</td>
                        <td class="py-1 px-1 text-right">${formatter.format(cortadas)}</td>
                        <td class="py-1 px-1 text-right">${cortasPct.toFixed(2)}%</td>
                        <td class="py-1 px-1 text-right">${formatter.format(ingresoNeto)}</td>
                        <td class="py-1 px-1 text-right">${ingresoPct.toFixed(2)}%</td>
                        <td class="py-1 px-1 text-right">${formatter.format(despachoAlmacen)}</td>
                        <td class="py-1 px-1 text-right">${despPct.toFixed(2)}%</td>
                    `;
                    modalFragment.appendChild(tr);
                });

                body.innerHTML = '';
                body.appendChild(modalFragment);

                // Actualizar totales en footer
                const totalProgPct = totalPedido ? (totalProg / totalPedido * 100) : 0;
                const totalGiroPct = totalPedido ? (totalGirado / totalPedido * 100) : 0;
                const totalCortasPct = totalPedido ? (totalCortadas / totalPedido * 100) : 0;
                const totalDespPct = totalPedido ? (totalDespachoAlmacen / totalPedido * 100) : 0;
                const totalIngresoPct = totalIngresoNeto ? (totalCortadas / totalIngresoNeto * 100) : 0;
                document.getElementById('modal3raTotalPedido').textContent = formatter.format(totalPedido);
                document.getElementById('modal3raTotalPedidoHM').textContent = formatter.format(totalPedidoHM);
                document.getElementById('modal3raTotalProg').textContent = formatter.format(totalProg);
                document.getElementById('modal3raTotalProgPct').textContent = totalProgPct.toFixed(2) + '%';
                document.getElementById('modal3raTotalGirado').textContent = formatter.format(totalGirado);
                document.getElementById('modal3raTotalGiroPct').textContent = totalGiroPct.toFixed(2) + '%';
                document.getElementById('modal3raTotalCortadas').textContent = formatter.format(totalCortadas);
                document.getElementById('modal3raTotalCortasPct').textContent = totalCortasPct.toFixed(2) + '%';
                document.getElementById('modal3raTotalDespachoAlmacen').textContent = formatter.format(totalDespachoAlmacen);
                document.getElementById('modal3raTotalDespPct').textContent = totalDespPct.toFixed(2) + '%';
                document.getElementById('modal3raTotalIngresoNeto').textContent = formatter.format(totalIngresoNeto);
                document.getElementById('modal3raTotalIngresoPct').textContent = totalIngresoPct.toFixed(2) + '%';

            } catch (err) {
                console.error('Error cargando detalle base por cliente', err);
                body.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">Error cargando datos</td></tr>';
            }
        }

        async function openModalSaldo2da(cliente) {
            const modal = document.getElementById('modalSaldo2daDetalle');
            const title = document.getElementById('modalSaldo2daTitle');
            const body = document.getElementById('modalSaldo2daBody');
            const formatter = new Intl.NumberFormat('es-PE');

            // Calcular porcentajes desde caché de clientes si está disponible
            let tipoOp = '';
            let saldo1ra = 0, saldo2da = 0, saldo3ra = 0, porcDesp = 0;
            try {
                if (cache && cache.clientes && Array.isArray(cache.clientes)) {
                    const found = cache.clientes.find(c => (c.cliente || '').toString().trim().toLowerCase() === cliente.toString().trim().toLowerCase());
                    if (found) {
                        saldo1ra = Number(found.porcentajeSaldo1ra) || 0;
                        saldo2da = Number(found.porcentajeSaldo2da) || 0;
                        saldo3ra = Number(found.porcentajeSaldo3ra) || 0;
                        porcDesp = found.prendasPedido ? (found.prendasDespacho / found.prendasPedido) * 100 : 0;
                        tipoOp = found.tipoOp || '';
                    }
                }
            } catch (e) { console.warn('Error leyendo cache.clientes', e); }

            const totalSaldo = saldo1ra + saldo2da + saldo3ra;
            title.innerHTML = `<div>${cliente} - Tipo: ${tipoOp}</div><div class="text-sm font-normal">%Saldo: 1ra (${saldo1ra.toFixed(2)}%) + 2da (${saldo2da.toFixed(2)}%) + 3ra (${saldo3ra.toFixed(2)}%) = ${totalSaldo.toFixed(2)}% &nbsp;-&nbsp; %Desp.= ${porcDesp.toFixed(2)}%</div>`;
            body.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">Cargando...</td></tr>';
            modal.classList.remove('hidden');

            try {
                // OPTIMIZACIÓN: Usar datos ya cargados en memoria en lugar de fetch
                if (!rawDataBase || rawDataBase.length <= 1) {
                    // Si no hay datos base, intentar cargarlos primero
                    body.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">Cargando datos base...</td></tr>';
                    await cargarDatosBase();
                    // Esperar un momento para que se procesen
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                // Filtrar datos de rawDataBase por cliente
                const rows = filtrarBaseByCliente(cliente);
                
                if (!rows || rows.length === 0) {
                    body.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">No hay datos disponibles</td></tr>';
                    return;
                }

                // Ordenar por %Corte de mayor a menor
                rows.sort((a, b) => {
                    const pedidoA = Number(a.pedido) || 0;
                    const cortadasA = Number(a.cortadas) || 0;
                    const cortasA = pedidoA ? (cortadasA / pedidoA * 100) : 0;
                    
                    const pedidoB = Number(b.pedido) || 0;
                    const cortadasB = Number(b.cortadas) || 0;
                    const cortasB = pedidoB ? (cortadasB / pedidoB * 100) : 0;
                    
                    return cortasB - cortasA; // De mayor a menor
                });

                const modalFragment = document.createDocumentFragment();
                let totalPedido = 0, totalPedidoHM = 0, totalProg = 0, totalGirado = 0, totalCortadas = 0, totalDespachoAlmacen = 0, totalIngresoNeto = 0;

                rows.forEach(r => {
                    const tr = document.createElement('tr');
                    tr.className = 'border-b';
                    const estilo = r.estilo || '';
                    const pedido = Number(r.pedido) || 0;
                    const pedidoHM = Number(r.pedidoHM) || 0;
                    const prog = Number(r.prog) || 0;
                    const girado = Number(r.girado) || 0;
                    const cortadas = Number(r.cortadas) || 0;
                    const despachoAlmacen = Number(r.despachoAlmacen) || 0;
                    const ingresoNeto = Number(r.ingresoNeto) || 0;
                    const progPct = pedido ? (prog / pedido * 100) : 0;
                    const giroPct = pedido ? (girado / pedido * 100) : 0;
                    const cortasPct = pedido ? (cortadas / pedido * 100) : 0;
                    const despPct = pedido ? (despachoAlmacen / pedido * 100) : 0;
                    const ingresoPct = ingresoNeto ? (cortadas / ingresoNeto * 100) : 0;

                    totalPedido += pedido;
                    totalPedidoHM += pedidoHM;
                    totalProg += prog;
                    totalGirado += girado;
                    totalCortadas += cortadas;
                    totalDespachoAlmacen += despachoAlmacen;
                    totalIngresoNeto += ingresoNeto;

                    tr.innerHTML = `
                        <td class="py-2 px-2">${estilo}</td>
                        <td class="py-1 px-1 text-right">${formatter.format(pedido)}</td>
                        <td class="py-1 px-1 text-right hidden">${formatter.format(pedidoHM)}</td>
                        <td class="py-1 px-1 text-right">${formatter.format(prog)}</td>
                        <td class="py-1 px-1 text-right">${progPct.toFixed(2)}%</td>
                        <td class="py-1 px-1 text-right">${formatter.format(girado)}</td>
                        <td class="py-1 px-1 text-right">${giroPct.toFixed(2)}%</td>
                        <td class="py-1 px-1 text-right">${formatter.format(cortadas)}</td>
                        <td class="py-1 px-1 text-right">${cortasPct.toFixed(2)}%</td>
                        <td class="py-1 px-1 text-right">${formatter.format(ingresoNeto)}</td>
                        <td class="py-1 px-1 text-right">${ingresoPct.toFixed(2)}%</td>
                        <td class="py-1 px-1 text-right">${formatter.format(despachoAlmacen)}</td>
                        <td class="py-1 px-1 text-right">${despPct.toFixed(2)}%</td>
                    `;
                    modalFragment.appendChild(tr);
                });

                body.innerHTML = '';
                body.appendChild(modalFragment);

                // Actualizar totales en footer
                const totalProgPct = totalPedido ? (totalProg / totalPedido * 100) : 0;
                const totalGiroPct = totalPedido ? (totalGirado / totalPedido * 100) : 0;
                const totalCortasPct = totalPedido ? (totalCortadas / totalPedido * 100) : 0;
                const totalDespPct = totalPedido ? (totalDespachoAlmacen / totalPedido * 100) : 0;
                const totalIngresoPct = totalIngresoNeto ? (totalCortadas / totalIngresoNeto * 100) : 0;
                document.getElementById('modal2daTotalPedido').textContent = formatter.format(totalPedido);
                document.getElementById('modal2daTotalPedidoHM').textContent = formatter.format(totalPedidoHM);
                document.getElementById('modal2daTotalProg').textContent = formatter.format(totalProg);
                document.getElementById('modal2daTotalProgPct').textContent = totalProgPct.toFixed(2) + '%';
                document.getElementById('modal2daTotalGirado').textContent = formatter.format(totalGirado);
                document.getElementById('modal2daTotalGiroPct').textContent = totalGiroPct.toFixed(2) + '%';
                document.getElementById('modal2daTotalCortadas').textContent = formatter.format(totalCortadas);
                document.getElementById('modal2daTotalCortasPct').textContent = totalCortasPct.toFixed(2) + '%';
                document.getElementById('modal2daTotalDespachoAlmacen').textContent = formatter.format(totalDespachoAlmacen);
                document.getElementById('modal2daTotalDespPct').textContent = totalDespPct.toFixed(2) + '%';
                document.getElementById('modal2daTotalIngresoNeto').textContent = formatter.format(totalIngresoNeto);
                document.getElementById('modal2daTotalIngresoPct').textContent = totalIngresoPct.toFixed(2) + '%';

            } catch (err) {
                console.error('Error cargando detalle base por cliente', err);
                body.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">Error cargando datos</td></tr>';
            }
        }

        async function openModalSaldo(cliente) {
            const modal = document.getElementById('modalSaldo1raDetalle');
            const title = document.getElementById('modalSaldoTitle');
            const body = document.getElementById('modalSaldoBody');
            const formatter = new Intl.NumberFormat('es-PE');

            // Calcular porcentajes desde caché de clientes si está disponible
            let tipoOp = '';
            let saldo1ra = 0, saldo2da = 0, saldo3ra = 0, porcDesp = 0;
            try {
                if (cache && cache.clientes && Array.isArray(cache.clientes)) {
                    const found = cache.clientes.find(c => (c.cliente || '').toString().trim().toLowerCase() === cliente.toString().trim().toLowerCase());
                    if (found) {
                        saldo1ra = Number(found.porcentajeSaldo1ra) || 0;
                        saldo2da = Number(found.porcentajeSaldo2da) || 0;
                        saldo3ra = Number(found.porcentajeSaldo3ra) || 0;
                        porcDesp = found.prendasPedido ? (found.prendasDespacho / found.prendasPedido) * 100 : 0;
                        tipoOp = found.tipoOp || '';
                    }
                }
            } catch (e) { console.warn('Error leyendo cache.clientes', e); }

            const totalSaldo = saldo1ra + saldo2da + saldo3ra;
            title.innerHTML = `<div>${cliente} - Tipo: ${tipoOp}</div><div class="text-sm font-normal">%Saldo: 1ra (${saldo1ra.toFixed(2)}%) + 2da (${saldo2da.toFixed(2)}%) + 3ra (${saldo3ra.toFixed(2)}%) = ${totalSaldo.toFixed(2)}% &nbsp;-&nbsp; %Desp.= ${porcDesp.toFixed(2)}%</div>`;
            body.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">Cargando...</td></tr>';
            modal.classList.remove('hidden');

            try {
                // OPTIMIZACIÓN: Usar datos ya cargados en memoria en lugar de fetch
                if (!rawDataBase || rawDataBase.length <= 1) {
                    // Si no hay datos base, intentar cargarlos primero
                    body.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">Cargando datos base...</td></tr>';
                    await cargarDatosBase();
                    // Esperar un momento para que se procesen
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                // Filtrar datos de rawDataBase por cliente
                const rows = filtrarBaseByCliente(cliente);
                
                if (!rows || rows.length === 0) {
                    body.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">No hay datos disponibles</td></tr>';
                    return;
                }

                // Ordenar por %Corte de mayor a menor
                rows.sort((a, b) => {
                    const pedidoA = Number(a.pedido) || 0;
                    const cortadasA = Number(a.cortadas) || 0;
                    const cortasA = pedidoA ? (cortadasA / pedidoA * 100) : 0;
                    
                    const pedidoB = Number(b.pedido) || 0;
                    const cortadasB = Number(b.cortadas) || 0;
                    const cortasB = pedidoB ? (cortadasB / pedidoB * 100) : 0;
                    
                    return cortasB - cortasA; // De mayor a menor
                });

                const modalFragment = document.createDocumentFragment();
                let totalPedido = 0, totalPedidoHM = 0, totalProg = 0, totalGirado = 0, totalCortadas = 0, totalDespachoAlmacen = 0, totalIngresoNeto = 0;

                rows.forEach(r => {
                    const tr = document.createElement('tr');
                    tr.className = 'border-b';
                    const estilo = r.estilo || '';
                    const pedido = Number(r.pedido) || 0;
                    const pedidoHM = Number(r.pedidoHM) || 0;
                    const prog = Number(r.prog) || 0;
                    const girado = Number(r.girado) || 0;
                    const cortadas = Number(r.cortadas) || 0;
                    const despachoAlmacen = Number(r.despachoAlmacen) || 0;
                    const ingresoNeto = Number(r.ingresoNeto) || 0;
                    const progPct = pedido ? (prog / pedido * 100) : 0;
                    const giroPct = pedido ? (girado / pedido * 100) : 0;
                    const cortasPct = pedido ? (cortadas / pedido * 100) : 0;
                    const despPct = pedido ? (despachoAlmacen / pedido * 100) : 0;
                    const ingresoPct = ingresoNeto ? (cortadas / ingresoNeto * 100) : 0;

                    totalPedido += pedido;
                    totalPedidoHM += pedidoHM;
                    totalProg += prog;
                    totalGirado += girado;
                    totalCortadas += cortadas;
                    totalDespachoAlmacen += despachoAlmacen;
                    totalIngresoNeto += ingresoNeto;

                    tr.innerHTML = `
                        <td class="py-2 px-2">${estilo}</td>
                        <td class="py-1 px-1 text-right">${formatter.format(pedido)}</td>
                        <td class="py-1 px-1 text-right hidden">${formatter.format(pedidoHM)}</td>
                        <td class="py-1 px-1 text-right">${formatter.format(prog)}</td>
                        <td class="py-1 px-1 text-right">${progPct.toFixed(2)}%</td>
                        <td class="py-1 px-1 text-right">${formatter.format(girado)}</td>
                        <td class="py-1 px-1 text-right">${giroPct.toFixed(2)}%</td>
                        <td class="py-1 px-1 text-right">${formatter.format(cortadas)}</td>
                        <td class="py-1 px-1 text-right">${cortasPct.toFixed(2)}%</td>
                        <td class="py-1 px-1 text-right">${formatter.format(ingresoNeto)}</td>
                        <td class="py-1 px-1 text-right">${ingresoPct.toFixed(2)}%</td>
                        <td class="py-1 px-1 text-right">${formatter.format(despachoAlmacen)}</td>
                        <td class="py-1 px-1 text-right">${despPct.toFixed(2)}%</td>
                    `;
                    modalFragment.appendChild(tr);
                });

                body.innerHTML = '';
                body.appendChild(modalFragment);

                // Actualizar totales en footer
                const totalProgPct = totalPedido ? (totalProg / totalPedido * 100) : 0;
                const totalGiroPct = totalPedido ? (totalGirado / totalPedido * 100) : 0;
                const totalCortasPct = totalPedido ? (totalCortadas / totalPedido * 100) : 0;
                const totalDespPct = totalPedido ? (totalDespachoAlmacen / totalPedido * 100) : 0;
                const totalIngresoPct = totalIngresoNeto ? (totalCortadas / totalIngresoNeto * 100) : 0;
                document.getElementById('modalTotalPedido').textContent = formatter.format(totalPedido);
                document.getElementById('modalTotalPedidoHM').textContent = formatter.format(totalPedidoHM);
                document.getElementById('modalTotalProg').textContent = formatter.format(totalProg);
                document.getElementById('modalTotalProgPct').textContent = totalProgPct.toFixed(2) + '%';
                document.getElementById('modalTotalGirado').textContent = formatter.format(totalGirado);
                document.getElementById('modalTotalGiroPct').textContent = totalGiroPct.toFixed(2) + '%';
                document.getElementById('modalTotalCortadas').textContent = formatter.format(totalCortadas);
                document.getElementById('modalTotalCortasPct').textContent = totalCortasPct.toFixed(2) + '%';
                document.getElementById('modalTotalDespachoAlmacen').textContent = formatter.format(totalDespachoAlmacen);
                document.getElementById('modalTotalDespPct').textContent = totalDespPct.toFixed(2) + '%';
                document.getElementById('modalTotalIngresoNeto').textContent = formatter.format(totalIngresoNeto);
                document.getElementById('modalTotalIngresoPct').textContent = totalIngresoPct.toFixed(2) + '%';

            } catch (err) {
                console.error('Error cargando detalle base por cliente', err);
                body.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">Error cargando datos</td></tr>';
            }
        }
        
        // Función para filtrar datos de la hoja base por cliente (en memoria)
        function filtrarBaseByCliente(clienteBuscado) {
            if (!rawDataBase || rawDataBase.length <= 1) return [];
            
            const headers = rawDataBase[0];
            const results = [];
            
            // Encontrar índices de columnas necesarias
            const findColIndex = (name) => {
                const nameLower = name.toLowerCase();
                return headers.findIndex(h => h && h.toString().toLowerCase().includes(nameLower));
            };
            
            const colAnio = findColIndex('año');
            const colMes = findColIndex('mes');
            const colCliente = findColIndex('cliente');
            const colEstilo = findColIndex('estilo');
            const colPedido = findColIndex('prendas pedido');
            const colPedidoHM = findColIndex('prendas pedido hm');
            const colProg = findColIndex('prendas prog');
            const colGirado = findColIndex('prendas girado');
            const colCortadas = findColIndex('prendas cortadas neto');
            const colDespachoAlmacen = findColIndex('prendas despacho almacen');
            // Buscar la columna de Ingreso Neto con múltiples variaciones posibles
            const colIngresoNeto = headers.findIndex(h => {
                const hLower = h && h.toString().toLowerCase();
                return hLower && (
                    hLower.includes('ingreso') || 
                    (hLower.includes('prend') && hLower.includes('ingreso')) ||
                    hLower.includes('prenda ingreso')
                ) && hLower.includes('neto');
            });
            
            // Diagnóstico
            console.log('Headers disponibles:', headers);
            console.log('Índices encontrados:', {
                colAnio, colMes, colCliente, colEstilo, colPedido, colPedidoHM,
                colProg, colGirado, colCortadas, colDespachoAlmacen, colIngresoNeto
            });
            
            if (colCliente === -1) {
                console.warn('Columna CLIENTE no encontrada en base');
                return [];
            }
            
            // Encontrar el último año y mes disponible (igual que en cargarDatosClientes)
            let ultimoAnio = null;
            let ultimoMes = null;
            const monthNames = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Set", "Oct", "Nov", "Dic"];
            
            if (colAnio !== -1 && colMes !== -1) {
                for (let i = 1; i < rawDataBase.length; i++) {
                    const row = rawDataBase[i];
                    const anio = row[colAnio];
                    const mes = row[colMes];
                    
                    if (anio && mes) {
                        if (ultimoAnio === null || anio > ultimoAnio) {
                            ultimoAnio = anio;
                            ultimoMes = mes;
                        } else if (anio === ultimoAnio) {
                            const mesIdx = monthNames.indexOf(String(mes));
                            const ultimoMesIdx = monthNames.indexOf(String(ultimoMes));
                            if (mesIdx > ultimoMesIdx) {
                                ultimoMes = mes;
                            }
                        }
                    }
                }
            }
            
            // Filtrar y agrupar por estilo (solo del último mes)
            const estiloMap = {};
            
            for (let i = 1; i < rawDataBase.length; i++) {
                const row = rawDataBase[i];
                
                // Filtrar por último año/mes si están disponibles
                if (colAnio !== -1 && colMes !== -1 && ultimoAnio !== null && ultimoMes !== null) {
                    if (row[colAnio] !== ultimoAnio || row[colMes] !== ultimoMes) {
                        continue;
                    }
                }
                
                const cliente = (row[colCliente] || '').toString().trim();
                
                // Comparar cliente ignorando mayúsculas
                if (cliente.toLowerCase() !== clienteBuscado.toLowerCase()) continue;
                
                const estilo = colEstilo !== -1 ? (row[colEstilo] || '').toString() : '';
                const pedido = colPedido !== -1 ? (parseFloat(row[colPedido]) || 0) : 0;
                const pedidoHM = colPedidoHM !== -1 ? (parseFloat(row[colPedidoHM]) || 0) : 0;
                const prog = colProg !== -1 ? (parseFloat(row[colProg]) || 0) : 0;
                const girado = colGirado !== -1 ? (parseFloat(row[colGirado]) || 0) : 0;
                const cortadas = colCortadas !== -1 ? (parseFloat(row[colCortadas]) || 0) : 0;
                const despachoAlmacen = colDespachoAlmacen !== -1 ? (parseFloat(row[colDespachoAlmacen]) || 0) : 0;
                const ingresoNeto = colIngresoNeto !== -1 ? (parseFloat(row[colIngresoNeto]) || 0) : 0;
                
                // Agrupar por estilo
                if (!estiloMap[estilo]) {
                    estiloMap[estilo] = {
                        estilo: estilo,
                        pedido: 0,
                        pedidoHM: 0,
                        prog: 0,
                        girado: 0,
                        cortadas: 0,
                        despachoAlmacen: 0,
                        ingresoNeto: 0
                    };
                }
                
                estiloMap[estilo].pedido += pedido;
                estiloMap[estilo].pedidoHM += pedidoHM;
                estiloMap[estilo].prog += prog;
                estiloMap[estilo].girado += girado;
                estiloMap[estilo].cortadas += cortadas;
                estiloMap[estilo].despachoAlmacen += despachoAlmacen;
                estiloMap[estilo].ingresoNeto += ingresoNeto;
            }
            
            return Object.values(estiloMap);
        }

        function actualizarGraficoClientes(data) {
            if (!charts.clientes || !data || data.length === 0) return;

            // Filtrar solo datos con Tipo OP = "P" para el gráfico
            const dataFiltrada = data.filter(row => row.tipoOp === 'P');

            // Agrupar por cliente (sumar prendasIngresoNeto, saldos1ra, prendasDespacho y prendasPedido)
            const map = {};
            dataFiltrada.forEach(row => {
                const cliente = (row.cliente || '').toString();
                if (!map[cliente]) map[cliente] = { cliente: cliente, prendasIngresoNeto: 0, saldos1ra: 0, prendasDespacho: 0, prendasPedido: 0 };
                map[cliente].prendasIngresoNeto += Number(row.prendasIngresoNeto) || 0;
                map[cliente].saldos1ra += Number(row.saldos1ra) || 0;
                map[cliente].prendasDespacho += Number(row.prendasDespacho) || 0;
                map[cliente].prendasPedido += Number(row.prendasPedido) || 0;
            });

            const aggregated = Object.values(map);
            // Calcular %Saldo1ra agregado por cliente
            aggregated.forEach(r => {
                r.porc = r.prendasIngresoNeto ? (r.saldos1ra / r.prendasIngresoNeto) * 100 : 0;
            });
            // Ordenar por %Saldo1ra descendente
            aggregated.sort((a, b) => b.porc - a.porc);

            const labels = aggregated.map(r => r.cliente || '');
            const prendasIngreso = aggregated.map(r => r.prendasIngresoNeto || 0);
            const porcSaldos = aggregated.map(r => r.porc || 0);

            // Guardar datos adicionales en el dataset para usarlos en tooltip
            charts.clientes.data.datasets[0].prendasDespacho = aggregated.map(r => r.prendasDespacho || 0);
            charts.clientes.data.datasets[0].prendasPedido = aggregated.map(r => r.prendasPedido || 0);

            // Actualizar en batch usando requestAnimationFrame
            requestAnimationFrame(() => {
                charts.clientes.data.labels = labels;
                charts.clientes.data.datasets[0].data = prendasIngreso;
                charts.clientes.data.datasets[1].data = porcSaldos;

                // Ajustar máximo del eje secundario
                try {
                    const maxPorc = porcSaldos.length ? Math.max(...porcSaldos.map(v => Number(v) || 0)) : 0;
                    const suggestedMax = maxPorc > 0 ? maxPorc * 1.25 : 1;
                    if (!charts.clientes.options.scales.y1) charts.clientes.options.scales.y1 = {};
                    charts.clientes.options.scales.y1.max = Math.round(suggestedMax * 100) / 100;
                    charts.clientes.options.scales.y1.min = -5;
                } catch (e) {
                    console.warn('No se pudo ajustar max del eje y1 en chartClientes', e);
                }

                charts.clientes.update('none');
            });
        }

        function actualizarTablaClientes2da(data) {
            const tbody = document.getElementById('tablaClientes2daBody');
            const periodo = document.getElementById('clientePeriodo2da');
            
            if (!data || data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">No hay datos disponibles</td></tr>';
                periodo.textContent = '';
                return;
            }

            // Mostrar periodo en el encabezado
            if (data[0].anio && data[0].mes) {
                periodo.textContent = `Gráfico producción (no muestras) - ${data[0].mes} ${data[0].anio}`;
            }

            // Crear copia de datos y ordenar por %Saldo 2da descendente
            const sortedData = [...data].sort((a, b) => (b.porcentajeSaldo2da || 0) - (a.porcentajeSaldo2da || 0));

            // Calcular totales
            const totals = data.reduce((acc, row) => {
                acc.prendasPedido += Number(row.prendasPedido) || 0;
                acc.prendasIngresoNeto += Number(row.prendasIngresoNeto) || 0;
                acc.saldos2da += Number(row.saldos2da) || 0;
                return acc;
            }, { prendasPedido: 0, prendasIngresoNeto: 0, saldos2da: 0 });

            const totalPorc = totals.prendasIngresoNeto ? (totals.saldos2da / totals.prendasIngresoNeto) * 100 : 0;

            // Generar filas usando DocumentFragment para mejor rendimiento
            const fragment = document.createDocumentFragment();
            const formatter = new Intl.NumberFormat('es-PE');
            
            sortedData.forEach(row => {
                const tr = document.createElement('tr');
                tr.className = 'border-b hover:bg-gray-50';
                const porcSaldo = row.porcentajeSaldo2da || 0;
                
                tr.innerHTML = `
                    <td class="py-2 px-2">${row.cliente || ''}</td>
                    <td class="py-2 px-2">${row.tipoOp || ''}</td>
                    <td class="py-2 px-2 text-right">${formatter.format(row.prendasPedido || 0)}</td>
                    <td class="py-2 px-2 text-right">${formatter.format(row.prendasIngresoNeto || 0)}</td>
                    <td class="py-2 px-2 text-right">${formatter.format(row.saldos2da || 0)}</td>
                    <td class="py-2 px-2 text-right font-semibold">${porcSaldo.toFixed(2)}%</td>
                `;
                fragment.appendChild(tr);
            });

            // Fila total
            const totalTr = document.createElement('tr');
            totalTr.className = 'bg-gray-800 text-white font-bold';
            totalTr.innerHTML = `
                <td class="py-2 px-2">TOTAL</td>
                <td class="py-2 px-2">&nbsp;</td>
                <td class="py-2 px-2 text-right">${formatter.format(totals.prendasPedido)}</td>
                <td class="py-2 px-2 text-right">${formatter.format(totals.prendasIngresoNeto)}</td>
                <td class="py-2 px-2 text-right">${formatter.format(totals.saldos2da)}</td>
                <td class="py-2 px-2 text-right">${totalPorc.toFixed(2)}%</td>
            `;
            fragment.appendChild(totalTr);

            // Actualizar DOM una sola vez
            tbody.innerHTML = '';
            tbody.appendChild(fragment);
        }

        function actualizarGraficoClientes2da(data) {
            if (!charts.clientes2da || !data || data.length === 0) return;

            // Filtrar solo datos con Tipo OP = "P" para el gráfico
            const dataFiltrada = data.filter(row => row.tipoOp === 'P');

            // Agrupar por cliente (sumar prendasIngresoNeto, saldos2da, prendasDespacho y prendasPedido)
            const map = {};
            dataFiltrada.forEach(row => {
                const cliente = (row.cliente || '').toString();
                if (!map[cliente]) map[cliente] = { cliente: cliente, prendasIngresoNeto: 0, saldos2da: 0, prendasDespacho: 0, prendasPedido: 0 };
                map[cliente].prendasIngresoNeto += Number(row.prendasIngresoNeto) || 0;
                map[cliente].saldos2da += Number(row.saldos2da) || 0;
                map[cliente].prendasDespacho += Number(row.prendasDespacho) || 0;
                map[cliente].prendasPedido += Number(row.prendasPedido) || 0;
            });

            const aggregated = Object.values(map);
            // Calcular %Saldo2da agregado por cliente
            aggregated.forEach(r => {
                r.porc = r.prendasIngresoNeto ? (r.saldos2da / r.prendasIngresoNeto) * 100 : 0;
            });
            // Ordenar por %Saldo2da descendente
            aggregated.sort((a, b) => b.porc - a.porc);

            const labels = aggregated.map(r => r.cliente || '');
            const prendasIngreso = aggregated.map(r => r.prendasIngresoNeto || 0);
            const porcSaldos = aggregated.map(r => r.porc || 0);

            // Guardar datos adicionales en el dataset para usarlos en tooltip
            charts.clientes2da.data.datasets[0].prendasDespacho = aggregated.map(r => r.prendasDespacho || 0);
            charts.clientes2da.data.datasets[0].prendasPedido = aggregated.map(r => r.prendasPedido || 0);

            // Actualizar en batch usando requestAnimationFrame
            requestAnimationFrame(() => {
                charts.clientes2da.data.labels = labels;
                charts.clientes2da.data.datasets[0].data = prendasIngreso;
                charts.clientes2da.data.datasets[1].data = porcSaldos;

                // Ajustar máximo del eje secundario
                try {
                    const maxPorc = porcSaldos.length ? Math.max(...porcSaldos.map(v => Number(v) || 0)) : 0;
                    const suggestedMax = maxPorc > 0 ? maxPorc * 1.25 : 1;
                    if (!charts.clientes2da.options.scales.y1) charts.clientes2da.options.scales.y1 = {};
                    charts.clientes2da.options.scales.y1.max = Math.round(suggestedMax * 100) / 100;
                    charts.clientes2da.options.scales.y1.min = -5;
                } catch (e) {
                    console.warn('No se pudo ajustar max del eje y1 en chartClientes2da', e);
                }

                charts.clientes2da.update('none');
            });
        }

        function actualizarTablaClientes3ra(data) {
            const tbody = document.getElementById('tablaClientes3raBody');
            const periodo = document.getElementById('clientePeriodo3ra');
            
            if (!data || data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">No hay datos disponibles</td></tr>';
                periodo.textContent = '';
                return;
            }

            // Mostrar periodo en el encabezado
            if (data[0].anio && data[0].mes) {
                periodo.textContent = `Gráfico producción (no muestras) - ${data[0].mes} ${data[0].anio}`;
            }

            // Crear copia de datos y ordenar por %Saldo 3ra descendente
            const sortedData = [...data].sort((a, b) => (b.porcentajeSaldo3ra || 0) - (a.porcentajeSaldo3ra || 0));

            // Calcular totales
            const totals = data.reduce((acc, row) => {
                acc.prendasPedido += Number(row.prendasPedido) || 0;
                acc.prendasIngresoNeto += Number(row.prendasIngresoNeto) || 0;
                acc.saldos3ra += Number(row.saldos3ra) || 0;
                return acc;
            }, { prendasPedido: 0, prendasIngresoNeto: 0, saldos3ra: 0 });

            const totalPorc = totals.prendasIngresoNeto ? (totals.saldos3ra / totals.prendasIngresoNeto) * 100 : 0;

            // Generar filas usando DocumentFragment para mejor rendimiento
            const fragment = document.createDocumentFragment();
            const formatter = new Intl.NumberFormat('es-PE');
            
            sortedData.forEach(row => {
                const tr = document.createElement('tr');
                tr.className = 'border-b hover:bg-gray-50';
                const porcSaldo = row.porcentajeSaldo3ra || 0;
                
                tr.innerHTML = `
                    <td class="py-2 px-2">${row.cliente || ''}</td>
                    <td class="py-2 px-2">${row.tipoOp || ''}</td>
                    <td class="py-2 px-2 text-right">${formatter.format(row.prendasPedido || 0)}</td>
                    <td class="py-2 px-2 text-right">${formatter.format(row.prendasIngresoNeto || 0)}</td>
                    <td class="py-2 px-2 text-right">${formatter.format(row.saldos3ra || 0)}</td>
                    <td class="py-2 px-2 text-right font-semibold">${porcSaldo.toFixed(2)}%</td>
                `;
                fragment.appendChild(tr);
            });

            // Fila total
            const totalTr = document.createElement('tr');
            totalTr.className = 'bg-gray-800 text-white font-bold';
            totalTr.innerHTML = `
                <td class="py-2 px-2">TOTAL</td>
                <td class="py-2 px-2">&nbsp;</td>
                <td class="py-2 px-2 text-right">${formatter.format(totals.prendasPedido)}</td>
                <td class="py-2 px-2 text-right">${formatter.format(totals.prendasIngresoNeto)}</td>
                <td class="py-2 px-2 text-right">${formatter.format(totals.saldos3ra)}</td>
                <td class="py-2 px-2 text-right">${totalPorc.toFixed(2)}%</td>
            `;
            fragment.appendChild(totalTr);

            // Actualizar DOM una sola vez
            tbody.innerHTML = '';
            tbody.appendChild(fragment);
        }

        function actualizarGraficoClientes3ra(data) {
            if (!charts.clientes3ra || !data || data.length === 0) return;

            // Filtrar solo datos con Tipo OP = "P" para el gráfico
            const dataFiltrada = data.filter(row => row.tipoOp === 'P');

            // Agrupar por cliente (sumar prendasIngresoNeto, saldos3ra, prendasDespacho y prendasPedido)
            const map = {};
            dataFiltrada.forEach(row => {
                const cliente = (row.cliente || '').toString();
                if (!map[cliente]) map[cliente] = { cliente: cliente, prendasIngresoNeto: 0, saldos3ra: 0, prendasDespacho: 0, prendasPedido: 0 };
                map[cliente].prendasIngresoNeto += Number(row.prendasIngresoNeto) || 0;
                map[cliente].saldos3ra += Number(row.saldos3ra) || 0;
                map[cliente].prendasDespacho += Number(row.prendasDespacho) || 0;
                map[cliente].prendasPedido += Number(row.prendasPedido) || 0;
            });

            const aggregated = Object.values(map);
            // Calcular %Saldo3ra agregado por cliente
            aggregated.forEach(r => {
                r.porc = r.prendasIngresoNeto ? (r.saldos3ra / r.prendasIngresoNeto) * 100 : 0;
            });
            // Ordenar por %Saldo3ra descendente
            aggregated.sort((a, b) => b.porc - a.porc);

            const labels = aggregated.map(r => r.cliente || '');
            const prendasIngreso = aggregated.map(r => r.prendasIngresoNeto || 0);
            const porcSaldos = aggregated.map(r => r.porc || 0);

            // Guardar datos adicionales en el dataset para usarlos en tooltip
            charts.clientes3ra.data.datasets[0].prendasDespacho = aggregated.map(r => r.prendasDespacho || 0);
            charts.clientes3ra.data.datasets[0].prendasPedido = aggregated.map(r => r.prendasPedido || 0);

            // Actualizar en batch usando requestAnimationFrame
            requestAnimationFrame(() => {
                charts.clientes3ra.data.labels = labels;
                charts.clientes3ra.data.datasets[0].data = prendasIngreso;
                charts.clientes3ra.data.datasets[1].data = porcSaldos;

                // Ajustar máximo del eje secundario
                try {
                    const maxPorc = porcSaldos.length ? Math.max(...porcSaldos.map(v => Number(v) || 0)) : 0;
                    const suggestedMax = maxPorc > 0 ? maxPorc * 1.25 : 1;
                    if (!charts.clientes3ra.options.scales.y1) charts.clientes3ra.options.scales.y1 = {};
                    charts.clientes3ra.options.scales.y1.max = Math.round(suggestedMax * 100) / 100;
                    charts.clientes3ra.options.scales.y1.min = -5;
                } catch (e) {
                    console.warn('No se pudo ajustar max del eje y1 en chartClientes3ra', e);
                }

                charts.clientes3ra.update('none');
            });
        }

        function actualizarTablaClientesHOD(data) {
            const tbody = document.getElementById('tablaClientesHODBody');
            const periodo = document.getElementById('hodPeriodo');
            
            if (!data || data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">No hay datos disponibles</td></tr>';
                periodo.textContent = '';
                return;
            }

            // Mostrar periodo en el encabezado
            if (data[0].anio && data[0].mes) {
                periodo.textContent = `Gráfico producción (no muestras) - ${data[0].mes} ${data[0].anio}`;
            }

            // Crear copia de datos y ordenar por %Desp. descendente (mayor a menor)
            const sortedData = [...data].map(row => {
                row.porcDesp = row.prendasPedido ? (row.prendasDespacho / row.prendasPedido) * 100 : 0;
                return row;
            }).sort((a, b) => (b.porcDesp || 0) - (a.porcDesp || 0));

            // Calcular totales
            const totals = data.reduce((acc, row) => {
                acc.prendasPedido += Number(row.prendasPedido) || 0;
                acc.prendasIngresoNeto += Number(row.prendasIngresoNeto) || 0;
                acc.prendasDespacho += Number(row.prendasDespacho) || 0;
                return acc;
            }, { prendasPedido: 0, prendasIngresoNeto: 0, prendasDespacho: 0 });

            const totalPorc = totals.prendasPedido ? (totals.prendasDespacho / totals.prendasPedido) * 100 : 0;

            // Generar filas usando DocumentFragment para mejor rendimiento
            const fragment = document.createDocumentFragment();
            const formatter = new Intl.NumberFormat('es-PE');
            
            sortedData.forEach(row => {
                const tr = document.createElement('tr');
                tr.className = 'border-b hover:bg-gray-50';
                
                tr.innerHTML = `
                    <td class="py-2 px-2">${row.cliente || ''}</td>
                    <td class="py-2 px-2">${row.tipoOp || ''}</td>
                    <td class="py-2 px-2 text-right">${formatter.format(row.prendasPedido || 0)}</td>
                    <td class="py-2 px-2 text-right">${formatter.format(row.prendasIngresoNeto || 0)}</td>
                    <td class="py-2 px-2 text-right">${formatter.format(row.prendasDespacho || 0)}</td>
                    <td class="py-2 px-2 text-right font-semibold">${row.porcDesp.toFixed(2)}%</td>
                `;
                fragment.appendChild(tr);
            });

            // Fila total
            const totalTr = document.createElement('tr');
            totalTr.className = 'bg-gray-800 text-white font-bold';
            totalTr.innerHTML = `
                <td class="py-2 px-2">TOTAL</td>
                <td class="py-2 px-2">&nbsp;</td>
                <td class="py-2 px-2 text-right">${formatter.format(totals.prendasPedido)}</td>
                <td class="py-2 px-2 text-right">${formatter.format(totals.prendasIngresoNeto)}</td>
                <td class="py-2 px-2 text-right">${formatter.format(totals.prendasDespacho)}</td>
                <td class="py-2 px-2 text-right">${totalPorc.toFixed(2)}%</td>
            `;
            fragment.appendChild(totalTr);

            // Actualizar DOM una sola vez
            tbody.innerHTML = '';
            tbody.appendChild(fragment);
        }

        function actualizarGraficoClientesHOD(data) {
            if (!charts.clientesHOD || !data || data.length === 0) return;

            // Filtrar solo datos con Tipo OP = "P" para el gráfico
            const dataFiltrada = data.filter(row => row.tipoOp === 'P');

            // Agrupar por cliente (sumar prendasPedido, prendasIngresoNeto, prendasDespacho y saldos1ra)
            const map = {};
            dataFiltrada.forEach(row => {
                const cliente = (row.cliente || '').toString();
                if (!map[cliente]) map[cliente] = { cliente: cliente, prendasPedido: 0, prendasIngresoNeto: 0, prendasDespacho: 0, saldos1ra: 0 };
                map[cliente].prendasPedido += Number(row.prendasPedido) || 0;
                map[cliente].prendasIngresoNeto += Number(row.prendasIngresoNeto) || 0;
                map[cliente].prendasDespacho += Number(row.prendasDespacho) || 0;
                map[cliente].saldos1ra += Number(row.saldos1ra) || 0;
            });

            const aggregated = Object.values(map);
            // Calcular %Desp agregado por cliente y %Saldo 1ra
            aggregated.forEach(r => {
                r.porc = r.prendasPedido ? (r.prendasDespacho / r.prendasPedido) * 100 : 0;
                r.porcSaldo1ra = r.prendasIngresoNeto ? (r.saldos1ra / r.prendasIngresoNeto) * 100 : 0;
            });
            // Ordenar por %Desp descendente
            aggregated.sort((a, b) => b.porc - a.porc);

            const labels = aggregated.map(r => r.cliente || '');
            const prendasDesp = aggregated.map(r => r.prendasDespacho || 0);
            const porcDesp = aggregated.map(r => r.porc || 0);

            // Guardar datos adicionales en el dataset para usarlos en tooltip
            charts.clientesHOD.data.datasets[0].prendasDespacho = aggregated.map(r => r.prendasDespacho || 0);
            charts.clientesHOD.data.datasets[0].porcDesp = aggregated.map(r => r.porc || 0);

            // Actualizar en batch usando requestAnimationFrame
            requestAnimationFrame(() => {
                charts.clientesHOD.data.labels = labels;
                charts.clientesHOD.data.datasets[0].data = prendasDesp;
                charts.clientesHOD.data.datasets[1].data = porcDesp;

                // Ajustar máximo del eje secundario
                try {
                    const maxPorc = porcDesp.length ? Math.max(...porcDesp.map(v => Number(v) || 0)) : 0;
                    const suggestedMax = maxPorc > 0 ? maxPorc * 1.25 : 1;
                    if (!charts.clientesHOD.options.scales.y1) charts.clientesHOD.options.scales.y1 = {};
                    charts.clientesHOD.options.scales.y1.max = Math.round(suggestedMax * 100) / 100;
                    charts.clientesHOD.options.scales.y1.min = -5;
                } catch (e) {
                    console.warn('No se pudo ajustar max del eje y1 en chartClientesHOD', e);
                }

                charts.clientesHOD.update('none');
            });
        }

            // Función auxiliar para crear el botón +
            function crearBotonAgregar(columns) {
                const info = document.getElementById('accionesFilterInfo');
                if (info) {
                    info.innerHTML = '';
                    const btn = document.createElement('button');
                    btn.id = 'btnAgregarAccion';
                    btn.title = 'Agregar acción';
                    btn.className = 'inline-flex items-center justify-center h-8 w-8 bg-blue-600 hover:bg-blue-700 text-white rounded shadow';
                    btn.innerText = '+';
                    btn.addEventListener('click', () => agregarFilaEditable(columns));
                    info.appendChild(btn);
                }
            }

            // Cargar acciones desde la hoja 'acciones' via Google Visualization API y filtrar por columna 'Pestaña'
            async function cargarAcciones() {
                const tbody = document.getElementById('tablaAccionesBody');
                const thead = document.getElementById('tablaAccionesHead');
                const info = document.getElementById('accionesFilterInfo');
                
                if (tbody) tbody.innerHTML = '<tr><td colspan="4" class="py-2 text-center text-gray-400">Cargando...</td></tr>';
                if (thead) thead.innerHTML = '';
                if (info) info.textContent = '';

                return new Promise((resolve, reject) => {
                    try {
                        // Crear un callback único para esta carga
                        const callbackName = 'loadAccionesCallback_' + Date.now();
                        
                        // Definir el callback globalmente
                        window[callbackName] = function(jsonResponse) {
                            try {
                                if (!jsonResponse || !jsonResponse.table) {
                                    throw new Error("Respuesta inválida desde Google Visualization API");
                                }
                                
                                const cols = jsonResponse.table.cols.map(col => col.label || col.id || '');
                                const rows = jsonResponse.table.rows.map(r => r.c.map(cell => (cell && cell.v !== null) ? cell.v : ""));
                                
                                // Convertir a array de objetos
                                const allRows = rows.map(row => {
                                    const obj = {};
                                    cols.forEach((col, idx) => {
                                        obj[col] = row[idx];
                                    });
                                    return obj;
                                });
                                
                                if (!allRows || allRows.length === 0) {
                                    if (tbody) tbody.innerHTML = '<tr><td colspan="4" class="py-2 text-center text-gray-400">No hay datos de acciones</td></tr>';
                                    const defaultColumns = ['Pestaña', 'Problema', 'Acciones', 'Responsable', 'Fecha Fin'];
                                    crearBotonAgregar(defaultColumns);
                                    // Limpiar callback
                                    delete window[callbackName];
                                    resolve();
                                    return;
                                }
                                
                                // Detectar la clave de la columna que contiene 'pesta'
                                const pestaKey = cols.find(k => k && k.toLowerCase().includes('pesta')) || 'Pestaña';
                                const activeBtn = document.querySelector('.tab-button.active');
                                const currentTabName = activeBtn ? activeBtn.innerText.trim() : 'Pds no reportadas';
                                
                                // Filtrar por pestaña actual
                                const filtered = allRows.filter(r => {
                                    const val = r[pestaKey];
                                    return String(val || '').trim().toLowerCase() === currentTabName.toLowerCase();
                                });
                                
                                // Crear botón '+' para agregar filas
                                crearBotonAgregar(cols);
                                
                                // Renderizar tabla
                                renderTablaAcciones(filtered, cols);
                                
                                // Limpiar callback
                                delete window[callbackName];
                                resolve();
                            } catch (err) {
                                console.error('Error procesando datos de acciones:', err);
                                if (tbody) tbody.innerHTML = '<tr><td colspan="4" class="py-2 text-center text-gray-400">Error al procesar acciones</td></tr>';
                                const defaultColumns = ['Pestaña', 'Problema', 'Acciones', 'Responsable', 'Fecha Fin'];
                                crearBotonAgregar(defaultColumns);
                                delete window[callbackName];
                                reject(err);
                            }
                        };
                        
                        // Crear script para cargar datos
                        const script = document.createElement('script');
                        script.src = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?sheet=acciones&tqx=responseHandler:${callbackName}`;
                        script.onerror = () => {
                            console.error('Error cargando datos desde Google Visualization API');
                            if (tbody) tbody.innerHTML = '<tr><td colspan="4" class="py-2 text-center text-gray-400">Error al cargar acciones</td></tr>';
                            const defaultColumns = ['Pestaña', 'Problema', 'Acciones', 'Responsable', 'Fecha Fin'];
                            crearBotonAgregar(defaultColumns);
                            delete window[callbackName];
                            reject(new Error('Network error loading acciones'));
                        };
                        
                        // Timeout de 15 segundos
                        const timeoutId = setTimeout(() => {
                            if (window[callbackName]) {
                                console.error('Timeout cargando acciones');
                                if (tbody) tbody.innerHTML = '<tr><td colspan="4" class="py-2 text-center text-gray-400">Timeout al cargar acciones</td></tr>';
                                const defaultColumns = ['Pestaña', 'Problema', 'Acciones', 'Responsable', 'Fecha Fin'];
                                crearBotonAgregar(defaultColumns);
                                delete window[callbackName];
                                reject(new Error('Timeout loading acciones'));
                            }
                        }, 15000);
                        
                        // Guardar timeoutId en el callback para poder limpiarlo
                        window[callbackName]._timeoutId = timeoutId;
                        
                        document.body.appendChild(script);
                    } catch (err) {
                        console.error('Error iniciando carga de acciones:', err);
                        if (tbody) tbody.innerHTML = '<tr><td colspan="4" class="py-2 text-center text-gray-400">Error al cargar acciones</td></tr>';
                        const defaultColumns = ['Pestaña', 'Problema', 'Acciones', 'Responsable', 'Fecha Fin'];
                        crearBotonAgregar(defaultColumns);
                        reject(err);
                    }
                });
            }

            function renderTablaAcciones(rows, columns) {
                const thead = document.getElementById('tablaAccionesHead');
                const tbody = document.getElementById('tablaAccionesBody');
                if (!thead || !tbody) return;

                // Construir header y body
                const pestaIdxLocal = columns.findIndex(c => c && c.toLowerCase().includes('pesta'));
                const visibleColumns = columns.filter((c, idx) => idx !== pestaIdxLocal);

                // calcular anchos fijos por columna visible (una sola vez)
                const widthMap = { 'problema': 20, 'accion': 60, 'respons': 10, 'fecha': 10 };
                const assignedVisible = visibleColumns.map(c => {
                    const k = (c || '').toString().toLowerCase();
                    for (const key in widthMap) {
                        if (k.includes(key)) return widthMap[key];
                    }
                    return 0;
                });
                
                let ssum = assignedVisible.reduce((a,b)=>a+b,0);
                if (ssum === 0) {
                    const eq = Math.floor(100 / visibleColumns.length);
                    assignedVisible.fill(eq);
                    assignedVisible[assignedVisible.length-1] += 100 - eq * visibleColumns.length;
                } else if (ssum !== 100) {
                    const factor = 100 / ssum;
                    for (let i=0; i<assignedVisible.length; i++) {
                        assignedVisible[i] = Math.round(assignedVisible[i]*factor);
                    }
                    let s2 = assignedVisible.reduce((a,b)=>a+b,0);
                    if (s2 !== 100) assignedVisible[assignedVisible.length-1] += 100 - s2;
                }

                // header con innerHTML para mayor velocidad
                const headerHTML = visibleColumns.map((col, i) => 
                    `<th class="py-2 px-2 border-b text-left text-xs font-bold text-white" style="width:${assignedVisible[i]}%">${col}</th>`
                ).join('');
                thead.innerHTML = `<tr>${headerHTML}</tr>`;

                // body
                if (!rows || rows.length === 0) {
                    tbody.innerHTML = `<tr><td colspan="${visibleColumns.length}" class="py-2 text-center text-gray-400">No hay acciones</td></tr>`;
                    return;
                }

                // Caché de meses para evitar crear el array repetidamente
                const months = ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Set','Oct','Nov','Dic'];
                
                // Función optimizada para formatear fechas
                const formatValue = (v) => {
                    if (v === null || v === undefined || v === '') return '';

                    // Manejar cadenas con formato Date(YYYY,MM,DD) o new Date(...)
                    if (typeof v === 'string') {
                        const ctorMatch = v.match(/Date\((\d+),\s*(\d+),\s*(\d+)\)/i);
                        if (ctorMatch) {
                            const y = parseInt(ctorMatch[1], 10);
                            const m = parseInt(ctorMatch[2], 10);
                            const d = parseInt(ctorMatch[3], 10);
                            const parsedCtor = new Date(y, m, d);
                            if (!isNaN(parsedCtor.getTime())) {
                                return `${String(parsedCtor.getDate()).padStart(2,'0')}/${months[parsedCtor.getMonth()]}/${parsedCtor.getFullYear()}`;
                            }
                        }

                        // Intentar parsear fecha solo si parece una fecha estándar
                        if (v.includes('T') || v.includes('-') || v.includes('/')) {
                            const parsed = new Date(v);
                            if (!isNaN(parsed.getTime())) {
                                return `${String(parsed.getDate()).padStart(2,'0')}/${months[parsed.getMonth()]}/${parsed.getFullYear()}`;
                            }
                        }
                    } else if (v instanceof Date && !isNaN(v.getTime())) {
                        return `${String(v.getDate()).padStart(2,'0')}/${months[v.getMonth()]}/${v.getFullYear()}`;
                    }
                    return String(v);
                };

                // Construir todo el HTML de una vez (mucho más rápido que createElement)
                const rowsHTML = rows.map(r => {
                    const cellsHTML = visibleColumns.map((col, i) => 
                        `<td class="py-2 px-2" style="width:${assignedVisible[i]}%">${formatValue(r[col])}</td>`
                    ).join('');
                    return `<tr class="border-b">${cellsHTML}</tr>`;
                }).join('');
                
                tbody.innerHTML = rowsHTML;

                // ocultar info de anchos
                const infoEl = document.getElementById('accionesColWidths');
                if (infoEl) infoEl.innerHTML = '';
            }

            // Renderizar solo los encabezados de la tabla
            function renderHeadersAcciones(columns) {
                const thead = document.getElementById('tablaAccionesHead');
                if (!thead) return;

                const pestaIdxLocal = columns.findIndex(c => c && c.toLowerCase().includes('pesta'));
                const visibleColumns = columns.filter((c, idx) => idx !== pestaIdxLocal);

                // calcular anchos fijos por columna visible
                const widthMap = { 'problema': 20, 'accion': 60, 'respons': 10, 'fecha': 10 };
                const assignedVisible = visibleColumns.map(c => {
                    const k = (c || '').toString().toLowerCase();
                    for (const key in widthMap) {
                        if (k.includes(key)) return widthMap[key];
                    }
                    return 0;
                });
                
                let ssum = assignedVisible.reduce((a,b)=>a+b,0);
                if (ssum === 0) {
                    const eq = Math.floor(100 / visibleColumns.length);
                    assignedVisible.fill(eq);
                    assignedVisible[assignedVisible.length-1] += 100 - eq * visibleColumns.length;
                } else if (ssum !== 100) {
                    const factor = 100 / ssum;
                    for (let i=0; i<assignedVisible.length; i++) {
                        assignedVisible[i] = Math.round(assignedVisible[i]*factor);
                    }
                    let s2 = assignedVisible.reduce((a,b)=>a+b,0);
                    if (s2 !== 100) assignedVisible[assignedVisible.length-1] += 100 - s2;
                }

                // header con innerHTML para mayor velocidad
                const headerHTML = visibleColumns.map((col, i) => 
                    `<th class="py-2 px-2 border-b text-left text-xs font-bold text-white" style="width:${assignedVisible[i]}%">${col}</th>`
                ).join('');
                thead.innerHTML = `<tr>${headerHTML}</tr>`;
            }

            // Inserta una fila editable en la tabla de Acciones (al final)
            function agregarFilaEditable(columns) {
                const tbody = document.getElementById('tablaAccionesBody');
                const thead = document.getElementById('tablaAccionesHead');
                if (!tbody) return;

                // Si no hay headers, renderizarlos primero
                if (thead && !thead.innerHTML.trim()) {
                    renderHeadersAcciones(columns);
                }

                // Limpiar el mensaje "No hay datos" si existe
                const noDataRow = tbody.querySelector('tr td[colspan]');
                if (noDataRow) {
                    tbody.innerHTML = '';
                }

                // Si ya hay una fila editable, enfocar la primera celda
                const existing = tbody.querySelector('tr[data-editable="1"]');
                if (existing) {
                    const c = existing.querySelector('td[contenteditable]'); if (c) c.focus();
                    return;
                }

                const tr = document.createElement('tr');
                tr.className = 'border-b bg-yellow-50';
                tr.setAttribute('data-editable', '1');

                // Determinar nombre de pestaña activa
                function getActiveTabName() {
                    const btn = document.querySelector('.tab-button.active');
                    return btn ? btn.innerText.trim() : 'Pds no reportadas';
                }
                const activeTab = getActiveTabName();

                // localizar índice de columna 'pesta' (si existe) y 'fecha fin'
                const pestaIdx = columns.findIndex(c => c && c.toLowerCase().includes('pesta'));
                let fechaIdx = columns.findIndex(c => c && c.toLowerCase().includes('fecha') && c.toLowerCase().includes('fin'));
                if (fechaIdx === -1) fechaIdx = columns.findIndex(c => c && c.toLowerCase().includes('fecha'));

                columns.forEach((col, idx) => {
                    // No crear celda visual para la columna 'Pestaña' (se autocompleta al guardar)
                    if (idx === pestaIdx) return;

                    const td = document.createElement('td');
                    td.className = 'py-2 px-2';
                    td.dataset.col = col;
                    td.dataset.index = idx;

                    if (idx === fechaIdx) {
                        // Fecha Fin: mostrar input type=date prellenado con hoy
                        const input = document.createElement('input');
                        input.type = 'date';
                        input.className = 'w-full text-sm p-1 border rounded';
                        const hoy = new Date();
                        const yyyy = hoy.getFullYear();
                        const mm = String(hoy.getMonth() + 1).padStart(2,'0');
                        const dd = String(hoy.getDate()).padStart(2,'0');
                        input.value = yyyy + '-' + mm + '-' + dd;
                        // No autoguardar: el usuario debe presionar Guardar
                        td.appendChild(input);
                    } else {
                        td.contentEditable = 'true';
                        td.spellcheck = false;
                        td.addEventListener('keydown', function(e) {
                            if (e.key === 'Enter') { e.preventDefault(); this.blur(); }
                        });
                        // No autoguardar en blur: guardar se realiza con el botón Guardar
                    }
                    tr.appendChild(td);
                });

                // Insertar al final (debajo de todas las filas)
                tbody.appendChild(tr);

                // Foco en la primera editable celda (si existe)
                const firstEditable = tr.querySelector('td[contenteditable="true"]'); if (firstEditable) firstEditable.focus();

                // Añadir botones Guardar / Cancelar para controlar el guardado manual
                addSaveCancelButtons(tr, columns);
            }

            async function attemptSaveAccion(tr, columns) {
                if (!tr || tr.getAttribute('data-editable') !== '1') return;
                if (isSavingAccion) return; // evitar envíos concurrentes
                isSavingAccion = true;
                const btnG = document.getElementById('btnGuardarAccion');
                const btnC = document.getElementById('btnCancelarAccion');
                if (btnG) btnG.disabled = true;
                if (btnC) btnC.disabled = true;
                const cells = Array.from(tr.querySelectorAll('td'));
                const obj = {};
                let anyValue = false;
                cells.forEach(td => {
                    const key = td.dataset.col || '';
                    // Si contiene un input[type=date], tomar su valor y convertir a ISO
                    const inputDate = td.querySelector('input[type="date"]');
                    let val = '';
                    if (inputDate) {
                        const v = inputDate.value || '';
                        if (v) {
                            // convertir YYYY-MM-DD a ISO
                            try {
                                const dt = new Date(v + 'T00:00:00');
                                val = dt.toISOString();
                            } catch (e) {
                                val = v;
                            }
                        } else {
                            val = '';
                        }
                    } else {
                        val = (td.textContent || '').trim();
                    }
                    if (val !== '') anyValue = true;
                    obj[key] = val;
                });

                if (!anyValue) {
                    // eliminar fila vacía
                    tr.remove();
                    return;
                }

                // Asegurar que la columna 'Pestaña' tenga el valor de la pestaña activa
                let pestaKey = Object.keys(obj).find(k => k && k.toLowerCase().includes('pesta'));
                if (!pestaKey) {
                    // Si no está en obj (no se creó la celda), buscar en la lista de columnas
                    pestaKey = (columns || []).find(c => c && c.toLowerCase().includes('pesta'));
                }
                if (pestaKey) {
                    const btn = document.querySelector('.tab-button.active');
                    const activeTabName = btn ? btn.innerText.trim() : 'Pds no reportadas';
                    obj[pestaKey] = activeTabName;
                }

                // Mostrar estado
                tr.style.opacity = '0.6';
                try {
                    const saved = await saveAccion(obj);
                    tr.style.opacity = '1';
                    if (saved) {
                        // refrescar tabla completa para mantener consistencia
                        removeSaveCancelButtons();
                        cargarAcciones();
                    } else {
                        // Indicar error visualmente
                        tr.style.backgroundColor = '#fee2e2';
                        if (btnG) btnG.disabled = false;
                        if (btnC) btnC.disabled = false;
                    }
                } finally {
                    isSavingAccion = false;
                    if (btnG) btnG.disabled = false;
                    if (btnC) btnC.disabled = false;
                }
            }

            // Enviar nueva acción al servidor
            async function saveAccion(data) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000);

                    const response = await fetch(SCRIPT_URL, {
                        method: 'POST',
                        redirect: 'follow',
                        credentials: 'omit',
                        signal: controller.signal,
                        body: JSON.stringify({ action: 'saveAccion', data: data })
                    });

                    clearTimeout(timeoutId);
                    const result = await response.json();
                    if (result && result.status === 'success') return true;
                    console.error('Error guardando accion:', result && result.message);
                    return false;
                } catch (err) {
                    console.error('Error guardando accion:', err);
                    return false;
                }
            }

            // ==================== MODAL CLIENTE CHART ====================
            
            // Abrir modal de gráfico por cliente
            document.getElementById('btnModalClienteChart').addEventListener('click', function() {
                openModalClienteChart();
            });

            // Cerrar modal
            document.getElementById('modalClienteChartClose').addEventListener('click', closeModalClienteChart);
            document.getElementById('modalClienteChartOverlay').addEventListener('click', closeModalClienteChart);

            function closeModalClienteChart() {
                const modal = document.getElementById('modalClienteChart');
                if (modal) modal.classList.add('hidden');
            }

            // Cambio en el filtro de cliente
            document.getElementById('modalClienteFilter').addEventListener('change', function() {
                actualizarGraficoClienteModal();
            });

            function openModalClienteChart() {
                const modal = document.getElementById('modalClienteChart');
                modal.classList.remove('hidden');
                
                // Verificar si rawDataBase está cargado
                if (!rawDataBase || rawDataBase.length <= 1) {
                    console.warn('Datos base aún no disponibles, esperando...');
                    // Esperar a que los datos se carguen
                    const checkInterval = setInterval(() => {
                        if (rawDataBase && rawDataBase.length > 1) {
                            clearInterval(checkInterval);
                            cargarClientesEnFiltro();
                            actualizarGraficoClienteModal();
                            setTimeout(() => {
                                if (charts.clienteModal) charts.clienteModal.resize();
                            }, 100);
                        }
                    }, 100);
                    // Timeout de seguridad: máximo 5 segundos de espera
                    setTimeout(() => clearInterval(checkInterval), 5000);
                    return;
                }
                
                // Cargar lista de clientes en el select
                cargarClientesEnFiltro();
                
                // Actualizar gráfico con todos los clientes inicialmente
                actualizarGraficoClienteModal();
                
                // Redimensionar el gráfico después de que el modal sea visible
                setTimeout(() => {
                    if (charts.clienteModal) charts.clienteModal.resize();
                }, 100);
            }

            function cargarClientesEnFiltro() {
                const select = document.getElementById('modalClienteFilter');
                if (!select || !rawDataBase || rawDataBase.length <= 1) return;
                
                const headers = rawDataBase[0];
                
                // Buscar columna Cliente por nombre
                const colCliente = headers.findIndex(h => {
                    const hLower = (h || '').toString().toLowerCase().trim();
                    return hLower === 'cliente';
                });
                
                if (colCliente === -1) {
                    console.warn('No se encontró la columna Cliente en headers');
                    return;
                }
                
                // Obtener clientes únicos
                const clientesSet = new Set();
                for (let i = 1; i < rawDataBase.length; i++) {
                    const cliente = (rawDataBase[i][colCliente] || '').toString().trim();
                    if (cliente) clientesSet.add(cliente);
                }
                
                // Ordenar alfabéticamente
                const clientes = Array.from(clientesSet).sort();
                
                // Limpiar y poblar el select
                select.innerHTML = '<option value="">Todos los clientes</option>';
                clientes.forEach(cliente => {
                    const option = document.createElement('option');
                    option.value = cliente;
                    option.textContent = cliente;
                    select.appendChild(option);
                });
                
                // Establecer LULU como valor por defecto si existe
                if (clientes.includes('LULU')) {
                    select.value = 'LULU';
                } else if (clientes.length > 0) {
                    select.value = clientes[0];
                }
            }

            function actualizarGraficoClienteModal() {
                if (!charts.clienteModal || !rawDataBase || rawDataBase.length <= 1) return;
                
                const clienteSeleccionado = document.getElementById('modalClienteFilter').value;
                
                // Obtener rango de fechas del filtro principal
                const desdeAnio = parseInt(document.getElementById('desdeAnio').value);
                const hastaAnio = parseInt(document.getElementById('hastaAnio').value);
                const desdeMes = parseInt(document.getElementById('desdeMes').value);
                const hastaMes = parseInt(document.getElementById('hastaMes').value);
                
                const headers = rawDataBase[0];
                
                // Buscar índices de columnas por nombre en headers
                const colAnio = headers.findIndex(h => {
                    const hLower = (h || '').toString().toLowerCase().trim();
                    return hLower === 'año' || hLower === 'anio' || hLower === 'ano';
                });
                
                const colMes = headers.findIndex(h => {
                    const hLower = (h || '').toString().toLowerCase().trim();
                    return hLower === 'mes';
                });
                
                const colCliente = headers.findIndex(h => {
                    const hLower = (h || '').toString().toLowerCase().trim();
                    return hLower === 'cliente';
                });
                
                // Buscar índice de "Prendas Ingreso Neto" - buscar por nombre
                let colIngresoNeto = headers.findIndex(h => {
                    const hLower = (h || '').toString().toLowerCase();
                    return hLower.includes('prendas') && hLower.includes('ingreso') && hLower.includes('neto');
                });
                // Fallback: buscar solo "Ingreso Neto"
                if (colIngresoNeto === -1) {
                    colIngresoNeto = headers.findIndex(h => {
                        const hLower = (h || '').toString().toLowerCase();
                        return hLower.includes('ingreso') && hLower.includes('neto');
                    });
                }
                
                // Buscar índice de "Diferencia Liquidac.vs Ing+Reasig" - buscar en headers
                let colDiferencia = headers.findIndex(h => {
                    const hLower = (h || '').toString().toLowerCase();
                    return (hLower.includes('diferencia') && hLower.includes('liquidac')) || 
                           (hLower.includes('dif') && hLower.includes('liqu') && hLower.includes('ing'));
                });
                
                // Si no se encuentra, intentar buscar otra variación
                if (colDiferencia === -1) {
                    colDiferencia = headers.findIndex(h => {
                        const hLower = (h || '').toString().toLowerCase();
                        return hLower.includes('diferencia') && (hLower.includes('ing') || hLower.includes('reasig'));
                    });
                }
                // Fallback: buscar solo "Diferencia"
                if (colDiferencia === -1) {
                    colDiferencia = headers.findIndex(h => {
                        const hLower = (h || '').toString().toLowerCase();
                        return hLower.includes('diferencia');
                    });
                }
                
                console.log('Columnas encontradas - Año:', colAnio, 'Mes:', colMes, 'Cliente:', colCliente, 'IngresoNeto:', colIngresoNeto, 'Diferencia:', colDiferencia);
                console.log('Headers:', headers);
                
                // Validar que se encontraron las columnas esenciales
                if (colAnio === -1 || colMes === -1 || colCliente === -1 || colIngresoNeto === -1) {
                    console.warn('No se encontraron columnas esenciales en la hoja base');
                    return;
                }
                
                const monthsOrder = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Set", "Oct", "Nov", "Dic"];
                
                // Crear fechas numéricas para comparación (año * 12 + mes)
                const fechaDesde = desdeAnio * 12 + desdeMes;
                const fechaHasta = hastaAnio * 12 + hastaMes;
                
                // Si las fechas están invertidas, intercambiarlas
                const fechaMin = Math.min(fechaDesde, fechaHasta);
                const fechaMax = Math.max(fechaDesde, fechaHasta);
                
                // Agrupar datos por mes/año
                const dataMap = {};
                let registrosEncontrados = 0;
                let registrosFiltradosPorFecha = 0;
                let registrosFiltradosPorCliente = 0;
                
                for (let i = 1; i < rawDataBase.length; i++) {
                    const row = rawDataBase[i];
                    const anio = parseInt(row[colAnio]) || 0;
                    const mesTxt = (row[colMes] || '').toString().trim();
                    const mesIdx = monthsOrder.indexOf(mesTxt);
                    const cliente = (row[colCliente] || '').toString().trim();
                    
                    if (mesIdx === -1) continue;
                    
                    // Crear fecha numérica del registro para comparación
                    const fechaRegistro = anio * 12 + mesIdx;
                    
                    // Aplicar filtro de fechas usando comparación numérica simple
                    if (fechaRegistro < fechaMin || fechaRegistro > fechaMax) { 
                        registrosFiltradosPorFecha++; 
                        continue; 
                    }
                    
                    // Aplicar filtro de cliente si está seleccionado
                    if (clienteSeleccionado && cliente.toUpperCase() !== clienteSeleccionado.toUpperCase()) { 
                        registrosFiltradosPorCliente++; 
                        continue; 
                    }
                    
                    registrosEncontrados++;
                    const key = `${anio}|${mesTxt}`;
                    const ingresoNeto = parseFloat(row[colIngresoNeto]) || 0;
                    const diferencia = colDiferencia !== -1 ? (parseFloat(row[colDiferencia]) || 0) : 0;
                    
                    if (!dataMap[key]) {
                        dataMap[key] = {
                            anio: anio,
                            mes: mesTxt,
                            mesIdx: mesIdx,
                            ingresoNeto: 0,
                            diferencia: 0
                        };
                    }
                    
                    dataMap[key].ingresoNeto += ingresoNeto;
                    dataMap[key].diferencia += diferencia;
                }
                
                console.log('Filtro aplicado - Cliente:', clienteSeleccionado, 'Rango fecha:', fechaMin, '-', fechaMax);
                console.log('Registros encontrados:', registrosEncontrados, 'Filtrados por fecha:', registrosFiltradosPorFecha, 'Filtrados por cliente:', registrosFiltradosPorCliente);
                
                // Convertir a array y ordenar por fecha
                const dataArray = Object.values(dataMap).sort((a, b) => {
                    if (a.anio !== b.anio) return a.anio - b.anio;
                    return a.mesIdx - b.mesIdx;
                });
                
                // Preparar datos para el gráfico
                const labels = dataArray.map(d => `${d.mes} ${d.anio}`);
                const dataIngresoNeto = dataArray.map(d => d.ingresoNeto);
                const dataDiferencia = dataArray.map(d => Math.abs(d.diferencia)); // Multiplicar por -1 (valor absoluto para positivo)
                const dataPorcentaje = dataArray.map(d => {
                    if (d.ingresoNeto === 0) return 0;
                    return Number(((Math.abs(d.diferencia) / d.ingresoNeto) * 100).toFixed(2));
                });
                
                // Actualizar título con cliente seleccionado
                const title = document.getElementById('modalClienteChartTitle');
                if (clienteSeleccionado) {
                    title.textContent = `Ingreso Neto vs Diferencia - ${clienteSeleccionado}`;
                } else {
                    title.textContent = 'Ingreso Neto vs Diferencia por Cliente - Todos';
                }
                
                // Actualizar gráfico
                charts.clienteModal.data.labels = labels;
                charts.clienteModal.data.datasets[0].data = dataIngresoNeto;
                charts.clienteModal.data.datasets[1].data = dataDiferencia;
                charts.clienteModal.data.datasets[2].data = dataPorcentaje;
                
                // Ajustar eje Y secundario
                const maxPorc = dataPorcentaje.length ? Math.max(...dataPorcentaje) : 0;
                const suggestedMax = maxPorc > 0 ? maxPorc * 1.25 : 10;
                charts.clienteModal.options.scales.y1.max = Math.round(suggestedMax * 100) / 100;
                charts.clienteModal.options.scales.y1.min = -0.5;
                
                charts.clienteModal.update('none');
            }
    </script>
</body>
</html>

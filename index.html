<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indicadores de Liquidación</title>
    <!-- Tailwind CSS con precarga -->
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Iconos -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <style>
        .filter-select {
            border: 1px solid #D1D5DB;
            border-radius: 0.375rem;
            padding: 0.375rem 0.75rem;
            font-size: 0.875rem;
            outline: none;
            color: #374151;
            font-weight: 500;
        }
        .filter-select:focus {
            box-shadow: 0 0 0 4px rgba(59,130,246,0.08);
            border-color: #3B82F6;
        }
        .loader-overlay {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(2px);
        }
        /* Optimización de renderizado */
        canvas {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            /* Garantizar que los contenedores de los charts mantengan tamaño
               antes de que Chart.js los inicialice para evitar saltos de layout */
            min-height: 220px !important;
        }
        /* Indicador de estado */
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 8px;
        }
        .status-success { background-color: #10b981; }
        .status-loading { background-color: #f59e0b; animation: pulse 2s infinite; }
        .status-error { background-color: #ef4444; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        /* Estilos para tabs */
        .tab-button {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 500;
            border-radius: 0.5rem;
            transition: all 0.2s ease;
            background-color: #f3f4f6;
            color: #4b5563;
            border: none;
            cursor: pointer;
        }
        .tab-button:hover {
            background-color: #e5e7eb;
        }
        .tab-button.active {
            background-color: #2563eb;
            color: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .tab-content {
            display: none !important;
        }
        .tab-content.active {
            display: flex !important;
        }
    </style>
</head>
<body class="bg-slate-100 h-screen w-screen overflow-hidden flex flex-col p-4 font-sans relative">

    <!-- Loader General -->
    <div id="mainLoader" class="loader-overlay absolute inset-0 z-50 flex flex-col items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl p-6 flex flex-col items-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mb-3"></div>
            <p id="loaderText" class="text-blue-600 font-bold">Cargando datos...</p>
            <p class="text-gray-500 text-sm mt-1">Por favor espera</p>
        </div>
    </div>

    <!-- BLOQUE SUPERIOR: Título y Filtros -->
    <div class="bg-white rounded-xl shadow-sm p-4 mb-4 flex flex-col md:flex-row justify-between items-center gap-4 shrink-0">
        <div class="flex items-center gap-4">
            <div class="flex items-center gap-3">
                <div class="bg-blue-600 text-white p-2 rounded-lg">
                    <i class="fa-solid fa-chart-line text-xl"></i>
                </div>
                <div>
                    <h1 class="text-2xl font-bold text-gray-800 tracking-tight">Indicadores de Liquidación</h1>
                    <div id="connectionStatus" class="text-xs text-gray-500 flex items-center">
                        <span>Estado: </span>
                        <span id="statusText" class="ml-1 font-medium">Listo</span>
                        <span id="statusDot" class="status-indicator status-success"></span>
                    </div>
                </div>
            </div>
            <!-- Tabs de navegación -->
            <div class="flex items-center gap-2 ml-4 border-l pl-4 border-gray-300">
                <button id="tabPdsRegularizar" class="tab-button active" onclick="switchTab('pdsRegularizar')">
                    <i class="fa-solid fa-chart-column mr-1"></i>Pds por regularizar
                </button>
                <button id="tabSaldos" class="tab-button" onclick="switchTab('saldos')">
                    <i class="fa-solid fa-layer-group mr-1"></i>Saldos
                </button>
                <button id="tabSaldo1raCliente" class="tab-button" onclick="switchTab('saldo1raCliente')">
                    <i class="fa-solid fa-users mr-1"></i>Saldo 1ra x Cliente
                </button>
            </div>
        </div>

        <div class="flex flex-wrap items-center gap-3 bg-gray-50 p-2 rounded-lg border border-gray-100">
            <div class="flex items-center gap-2">
                <span class="text-xs font-bold text-gray-500 uppercase tracking-wide">Desde:</span>
                <select id="desdeAnio" class="filter-select bg-white">
                    <option value="2024">2024</option>
                    <option value="2025">2025</option>
                    <option value="2026">2026</option>
                </select>
                <select id="desdeMes" class="filter-select bg-white">
                    <option value="0">Ene</option><option value="1">Feb</option><option value="2">Mar</option>
                    <option value="3">Abr</option><option value="4">May</option><option value="5">Jun</option>
                    <option value="6">Jul</option><option value="7">Ago</option><option value="8">Set</option>
                    <option value="9">Oct</option><option value="10">Nov</option><option value="11">Dic</option>
                </select>
            </div>
            <div class="h-6 w-px bg-gray-300 mx-1"></div>
            <div class="flex items-center gap-2">
                <span class="text-xs font-bold text-gray-500 uppercase tracking-wide">Hasta:</span>
                <select id="hastaAnio" class="filter-select bg-white">
                    <option value="2024">2024</option>
                    <option value="2025">2025</option>
                    <option value="2026">2026</option>
                </select>
                <select id="hastaMes" class="filter-select bg-white">
                    <option value="0">Ene</option><option value="1">Feb</option><option value="2">Mar</option>
                    <option value="3">Abr</option><option value="4">May</option><option value="5">Jun</option>
                    <option value="6">Jul</option><option value="7">Ago</option><option value="8">Set</option>
                    <option value="9">Oct</option><option value="10">Nov</option><option value="11">Dic</option>
                </select>
            </div>
            
            <!-- Botón circular para cargar datos -->
            <div class="ml-2">
                <a href="importar_excel.html" title="Cargar datos" class="inline-flex items-center justify-center h-10 w-10 rounded-full bg-blue-600 hover:bg-blue-700 text-white shadow-md">
                    <i class="fa-solid fa-file-import"></i>
                </a>
            </div>
        </div>
    </div>

    <!-- BLOQUE INFERIOR: Contenido con Tabs -->
    
    <!-- Tab 1: Pds por regularizar -->
    <div id="contentPdsRegularizar" class="tab-content active flex-1 flex flex-col gap-1 min-h-0">
        <!-- Gráfico 1: Ingreso Neto vs %Diferencia -->
        <div class="bg-white rounded-xl shadow-sm p-4 border border-gray-200 flex flex-col relative min-h-0" style="flex: 0 0 60%;">
            <div class="flex items-start justify-between mb-2">
                <h3 id="chart1Title" class="text-gray-600 font-bold">Ingresos vs Liquidación</h3>
                <div id="chart1Legend" class="flex items-center gap-4"></div>
            </div>
            <div class="flex-1 w-full min-h-0 relative"><canvas id="chart1" style="width:100% !important; height:100% !important; display:block;"></canvas></div>
        </div>
            <!-- Bloque Acciones: tabla tomada desde la hoja 'acciones' filtrada por columna 'Pestaña' -->
            <div id="accionesBlock" class="bg-white rounded-xl shadow-sm p-4 border border-gray-200 mt-1 flex flex-col min-h-0" style="flex: 0 0 30%;">
                <div class="flex items-center justify-between mb-2">
                <h3 class="text-gray-600 font-bold">Acciones</h3>
                <div id="accionesFilterInfo" class="text-xs text-gray-500"></div>
            </div>
                <div class="overflow-auto h-full">
                    <table id="tablaAcciones" class="w-full text-sm">
                        <thead id="tablaAccionesHead" class="bg-gray-800 sticky top-0 text-white text-xs font-bold"></thead>
                        <tbody id="tablaAccionesBody" class="text-gray-700">
                            <tr><td colspan="4" class="py-2 text-center text-gray-400">Cargando...</td></tr>
                        </tbody>
                    </table>
                    <div id="accionesColWidths" class="text-xs text-gray-500 mt-2"></div>
                </div>
            </div>
    </div>

    <!-- Tab 2: Saldos -->
    <div id="contentSaldos" class="tab-content flex-1 flex flex-row gap-4 min-h-0 overflow-hidden">
        <!-- Bloque 1: Saldos 1ra -->
        <div class="bg-white rounded-xl shadow-sm p-4 border border-gray-200 flex flex-col relative min-h-0" style="flex: 1 1 33%;">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-gray-700 font-bold text-base flex items-center gap-2">
                    <span class="inline-flex items-center justify-center w-7 h-7 rounded-full bg-blue-100 text-blue-600 text-sm font-bold">1</span>
                    Saldos 1ra
                </h3>
                <span class="text-xs text-gray-400 font-medium">Ingreso Neto vs %Saldo</span>
            </div>
            <div class="flex-1 w-full min-h-0 relative">
                <canvas id="chart5" style="width:100% !important; height:100% !important; display:block;"></canvas>
            </div>
        </div>
        
        <!-- Bloque 2: Saldos 2da -->
        <div class="bg-white rounded-xl shadow-sm p-4 border border-gray-200 flex flex-col relative min-h-0" style="flex: 1 1 33%;">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-gray-700 font-bold text-base flex items-center gap-2">
                    <span class="inline-flex items-center justify-center w-7 h-7 rounded-full bg-amber-100 text-amber-600 text-sm font-bold">2</span>
                    Saldos 2da
                </h3>
                <span class="text-xs text-gray-400 font-medium">Ingreso Neto vs %Saldo</span>
            </div>
            <div class="flex-1 w-full min-h-0 relative">
                <canvas id="chart2" style="width:100% !important; height:100% !important; display:block;"></canvas>
            </div>
        </div>
        
        <!-- Bloque 3: Saldos 3ra -->
        <div class="bg-white rounded-xl shadow-sm p-4 border border-gray-200 flex flex-col relative min-h-0" style="flex: 1 1 33%;">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-gray-700 font-bold text-base flex items-center gap-2">
                    <span class="inline-flex items-center justify-center w-7 h-7 rounded-full bg-red-100 text-red-600 text-sm font-bold">3</span>
                    Saldos 3ra
                </h3>
                <span class="text-xs text-gray-400 font-medium">Ingreso Neto vs %Saldo</span>
            </div>
            <div class="flex-1 w-full min-h-0 relative">
                <canvas id="chart3" style="width:100% !important; height:100% !important; display:block;"></canvas>
            </div>
        </div>
    </div>

    <!-- Tab 3: Saldo 1ra x Cliente -->
    <div id="contentSaldo1raCliente" class="tab-content flex-1 flex flex-col gap-4 min-h-0">
        <!-- Detalle por Cliente de Saldos 1ra: Tabla + Gráfico -->
        <div class="bg-white rounded-xl shadow-sm p-4 border border-gray-200 flex flex-col relative gap-2">
            <div class="flex items-center justify-between mb-0">
                <h3 class="text-gray-600 font-bold">Detalle por Cliente de Saldos 1ra</h3>
                <span id="clientePeriodo" class="text-xs text-gray-500 font-medium"></span>
            </div>
            
            <!-- Contenedor flex para tabla y gráfico lado a lado -->
            <div class="flex-1 flex flex-col md:flex-row gap-4 min-h-0">
                <!-- Tabla de clientes (50% ancho en desktop) -->
                <div class="w-full md:w-1/2 overflow-auto min-h-0 max-h-full">
                    <table id="tablaClientes" class="w-full text-sm">
                        <thead class="bg-gray-800 sticky top-0">
                            <tr class="text-left text-xs font-bold text-white">
                                <th class="py-2 px-2 border-b">Cliente</th>
                                <th class="py-2 px-2 border-b">Tipo</th>
                                <th class="py-2 px-2 border-b text-right">Prendas Pedido</th>
                                <th class="py-2 px-2 border-b text-right">Prendas Ingreso Neto</th>
                                <th class="py-2 px-2 border-b text-right">Saldos 1ra</th>
                                <th class="py-2 px-2 border-b text-right">%Saldo 1ra</th>
                            </tr>
                        </thead>
                        <tbody id="tablaClientesBody" class="text-gray-700">
                            <tr><td colspan="6" class="py-2 text-center text-gray-400">Cargando...</td></tr>
                        </tbody>
                    </table>
                </div>

                <!-- Gráfico de clientes (50% ancho en desktop) -->
                <div class="w-full md:w-1/2 min-h-0 relative" style="min-height: 300px;"><canvas id="chartClientes" style="display:block; width:100% !important; height:100% !important;"></canvas></div>
            </div>
        </div>
    </div>

    <script>
        // URL proporcionada por el usuario
        const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbwtAS-n3FikPNCC-3zjDuyzC8YKoD0NcVvy5UgWtCzsHjX6JOBiwu8otfBeViNa6lercw/exec";

        // Función para cambiar entre pestañas
        function switchTab(tabName) {
            // Ocultar todos los contenidos
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Desactivar todos los botones de tab
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Activar el contenido y botón correspondiente
            if (tabName === 'pdsRegularizar') {
                document.getElementById('contentPdsRegularizar').classList.add('active');
                document.getElementById('tabPdsRegularizar').classList.add('active');
                // Forzar redimensionamiento del gráfico
                setTimeout(() => {
                    if (charts.c1) charts.c1.resize();
                }, 50);
            } else if (tabName === 'saldos') {
                document.getElementById('contentSaldos').classList.add('active');
                document.getElementById('tabSaldos').classList.add('active');
                // Forzar redimensionamiento de los gráficos
                setTimeout(() => {
                    if (charts.c5) charts.c5.resize();
                    if (charts.c2) charts.c2.resize();
                    if (charts.c3) charts.c3.resize();
                }, 50);
            } else if (tabName === 'saldo1raCliente') {
                document.getElementById('contentSaldo1raCliente').classList.add('active');
                document.getElementById('tabSaldo1raCliente').classList.add('active');
                // Forzar redimensionamiento del gráfico
                setTimeout(() => {
                    if (charts.clientes) charts.clientes.resize();
                }, 50);
            }

        }

        // Añadir/Remover botones Guardar / Cancelar junto al '+'
        function addSaveCancelButtons(tr, columns) {
            const info = document.getElementById('accionesFilterInfo');
            if (!info) return;
            // evitar duplicados
            removeSaveCancelButtons();

            const btnGuardar = document.createElement('button');
            btnGuardar.id = 'btnGuardarAccion';
            btnGuardar.className = 'ml-2 inline-flex items-center gap-2 px-3 py-1 rounded bg-green-600 text-white';
            btnGuardar.textContent = 'Guardar';
            btnGuardar.addEventListener('click', async () => {
                // validar campos: todos los td (excepto pestaña que no existe) deben tener valor
                const cells = Array.from(tr.querySelectorAll('td'));
                const dataOk = cells.every(td => {
                    const input = td.querySelector('input[type="date"]');
                    const v = input ? (input.value || '') : (td.textContent || '').trim();
                    return String(v).trim() !== '';
                });
                if (!dataOk) {
                    alert('Por favor complete todos los campos antes de guardar.');
                    return;
                }

                const confirmed = await showConfirm('¿Quiere registrar la Acción?');
                if (confirmed) {
                    attemptSaveAccion(tr, columns);
                }
            });

            const btnCancelar = document.createElement('button');
            btnCancelar.id = 'btnCancelarAccion';
            btnCancelar.className = 'ml-2 inline-flex items-center gap-2 px-3 py-1 rounded bg-gray-300 text-gray-700';
            btnCancelar.textContent = 'Cancelar';
            btnCancelar.addEventListener('click', () => {
                tr.remove();
                removeSaveCancelButtons();
            });

            info.appendChild(btnGuardar);
            info.appendChild(btnCancelar);
        }

        function removeSaveCancelButtons() {
            const btnG = document.getElementById('btnGuardarAccion');
            const btnC = document.getElementById('btnCancelarAccion');
            if (btnG) btnG.remove();
            if (btnC) btnC.remove();
        }

        // Modal confirm returning Promise<boolean>
        function showConfirm(message) {
            return new Promise(resolve => {
                // crear overlay
                const overlay = document.createElement('div');
                overlay.style.position = 'fixed'; overlay.style.inset = '0'; overlay.style.display = 'flex';
                overlay.style.alignItems = 'center'; overlay.style.justifyContent = 'center'; overlay.style.zIndex = 9999;
                overlay.style.background = 'rgba(0,0,0,0.4)';

                const box = document.createElement('div');
                box.style.background = 'white'; box.style.borderRadius = '8px'; box.style.padding = '18px'; box.style.minWidth = '320px';
                box.style.boxShadow = '0 8px 24px rgba(0,0,0,0.2)';

                const msg = document.createElement('div'); msg.textContent = message; msg.style.marginBottom = '12px';
                const btnRow = document.createElement('div'); btnRow.style.display = 'flex'; btnRow.style.justifyContent = 'flex-end'; btnRow.style.gap = '8px';

                const noBtn = document.createElement('button'); noBtn.textContent = 'No'; noBtn.className = 'px-3 py-1 rounded bg-gray-200';
                const yesBtn = document.createElement('button'); yesBtn.textContent = 'Si'; yesBtn.className = 'px-3 py-1 rounded bg-blue-600 text-white';

                noBtn.addEventListener('click', () => { overlay.remove(); resolve(false); });
                yesBtn.addEventListener('click', () => { overlay.remove(); resolve(true); });

                btnRow.appendChild(noBtn); btnRow.appendChild(yesBtn);
                box.appendChild(msg); box.appendChild(btnRow);
                overlay.appendChild(box);
                document.body.appendChild(overlay);
            });
        }
        
        let charts = {};
        let isSavingAccion = false;
        const monthNames = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Set", "Oct", "Nov", "Dic"];
        
        // Caché para optimizar llamadas repetidas
        const cache = {
            dashboard: null,
            clientes: null,
            lastParams: null,
            timestamp: null,
            TTL: 30000 // 30 segundos de validez
        };
        
        // Funciones para actualizar el estado de conexión
        function setConnectionStatus(status, text) {
            const statusText = document.getElementById('statusText');
            const statusDot = document.getElementById('statusDot');
            if (statusText) statusText.textContent = text;
            if (statusDot) {
                statusDot.className = 'status-indicator';
                statusDot.classList.add(`status-${status}`);
            }
        }

        // Helper: formato corto para ejes (5,000 -> 5k, 10,000 -> 10k)
        function formatShortNumber(val) {
            if (val === null || val === undefined) return '' + val;
            const n = Number(val);
            if (isNaN(n)) return String(val);
            const abs = Math.abs(n);
            if (abs >= 1000) {
                const k = n / 1000;
                return (Number.isInteger(k) ? k.toString() : k.toFixed(1).replace(/\.0$/,'')) + 'k';
            }
            return new Intl.NumberFormat('es-PE').format(n);
        }

        document.addEventListener('DOMContentLoaded', async () => {
            // Cargar años en segundo plano sin bloquear
            cargarAniosDesdeBase().catch(e => console.warn('Error cargando años:', e));
            
            establecerFechasPorDefecto();
            initCharts();
            cargarDatosIniciales(); // Carga paralela optimizada
            
            // Debounce para evitar múltiples llamadas al cambiar filtros
            let filterTimeout;
            document.querySelectorAll('select').forEach(sel => {
                sel.addEventListener('change', () => {
                    clearTimeout(filterTimeout);
                    // Invalidar caché al cambiar filtros
                    cache.dashboard = null;
                    cache.lastParams = null;
                    filterTimeout = setTimeout(() => {
                        actualizarGraficos();
                    }, 300); // 300ms de espera
                });
            });
        });
        
        // Cargar datos iniciales de forma optimizada
        async function cargarDatosIniciales() {
            const loading = document.getElementById('mainLoader');
            const loaderText = document.getElementById('loaderText');
            loading.classList.remove('hidden');
            setConnectionStatus('loading', 'Cargando...');
            
            try {
                // PRIORIDAD 1: Cargar primero los gráficos principales (lo más importante)
                loaderText.textContent = 'Cargando gráficos...';
                await actualizarGraficos(true);
                
                // Ocultar loader principal ya que los gráficos están listos
                loading.classList.add('hidden');
                setConnectionStatus('success', 'Conectado');
                
                // PRIORIDAD 2: Cargar tablas secundarias en segundo plano (no bloquean)
                loaderText.textContent = 'Cargando datos adicionales...';
                Promise.all([
                    cargarDatosClientes().catch(e => console.warn('Error cargando clientes:', e)),
                    cargarAcciones().catch(e => console.warn('Error cargando acciones:', e))
                ]).then(() => {
                    console.log('Todos los datos cargados completamente');
                }).catch(error => {
                    console.error("Error en carga secundaria:", error);
                });
                
            } catch (error) {
                console.error("Error en carga inicial:", error);
                setConnectionStatus('error', 'Error de conexión');
                loading.classList.add('hidden');
            }
        }

        // Cargar años disponibles desde la hoja 'base' (servidor) y poblar selects
        async function cargarAniosDesdeBase() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);

                const resp = await fetch(SCRIPT_URL, {
                    method: 'POST',
                    redirect: 'follow',
                    credentials: 'omit',
                    signal: controller.signal,
                    body: JSON.stringify({ action: 'getAvailableYears' })
                });

                clearTimeout(timeoutId);
                const result = await resp.json();
                if (result.status === 'success' && Array.isArray(result.data)) {
                    const years = result.data;
                    const desdeSel = document.getElementById('desdeAnio');
                    const hastaSel = document.getElementById('hastaAnio');
                    if (!desdeSel || !hastaSel) return;

                    // Limpiar opciones actuales
                    desdeSel.innerHTML = '';
                    hastaSel.innerHTML = '';

                    // Asegurar que sean únicos y ordenados
                    const unique = Array.from(new Set(years.map(y => String(y))));
                    unique.forEach(y => {
                        const o1 = document.createElement('option'); o1.value = y; o1.textContent = y;
                        const o2 = document.createElement('option'); o2.value = y; o2.textContent = y;
                        desdeSel.appendChild(o1);
                        hastaSel.appendChild(o2);
                    });

                    // Si no se obtuvo ningún año, mantener las opciones estáticas existentes
                    if (unique.length === 0) {
                        // dejar tal cual; no hacer nada
                    }
                } else {
                    console.warn('No se obtuvieron años desde el servidor:', result && result.message);
                }
            } catch (e) {
                if (e.name === 'AbortError') console.warn('Timeout cargando años');
                else console.error('Error cargando años:', e);
            }
        }

        function establecerFechasPorDefecto() {
            const hoy = new Date();
            const fechaHasta = new Date(hoy.getFullYear(), hoy.getMonth() - 1, 1);
            // Mostrar 9 meses en el filtro: desde = hasta - 8 meses
            const fechaDesde = new Date(fechaHasta.getFullYear(), fechaHasta.getMonth() - 8, 1);

            document.getElementById('hastaAnio').value = fechaHasta.getFullYear();
            document.getElementById('hastaMes').value = fechaHasta.getMonth();
            document.getElementById('desdeAnio').value = fechaDesde.getFullYear();
            document.getElementById('desdeMes').value = fechaDesde.getMonth();
        }

        function actualizarTituloChart1() {
            const desdeAnio = document.getElementById('desdeAnio').value;
            const hastaAnio = document.getElementById('hastaAnio').value;
            const desdeMesIdx = parseInt(document.getElementById('desdeMes').value, 10);
            const hastaMesIdx = parseInt(document.getElementById('hastaMes').value, 10);
            const desdeMes = monthNames[desdeMesIdx] || '';
            const hastaMes = monthNames[hastaMesIdx] || '';

            let rangeText = '';
            if (desdeAnio === hastaAnio) {
                rangeText = `(${desdeMes} - ${hastaMes} ${hastaAnio})`;
            } else {
                rangeText = `(${desdeMes} ${desdeAnio} - ${hastaMes} ${hastaAnio})`;
            }

            const title = `Ingreso Neto vs %Dif. Liquidac. ${rangeText}`;
            const el = document.getElementById('chart1Title');
            if (el) el.innerText = title;
        }

        function actualizarTituloEvolucion() {
            const desdeAnio = document.getElementById('desdeAnio').value;
            const hastaAnio = document.getElementById('hastaAnio').value;
            const desdeMesIdx = parseInt(document.getElementById('desdeMes').value, 10);
            const hastaMesIdx = parseInt(document.getElementById('hastaMes').value, 10);
            const desdeMes = monthNames[desdeMesIdx] || '';
            const hastaMes = monthNames[hastaMesIdx] || '';

            let rangeText = '';
            if (desdeAnio === hastaAnio) {
                rangeText = `(${desdeMes} - ${hastaMes} ${hastaAnio})`;
            } else {
                rangeText = `(${desdeMes} ${desdeAnio} - ${hastaMes} ${hastaAnio})`;
            }

            const title = `Ingreso Neto vs %Saldos ${rangeText}`;
            const el = document.getElementById('chartEvoTitle');
            if (el) el.innerText = title;
        }

        function renderChart1Legend() {
            const container = document.getElementById('chart1Legend');
            if (!container || !charts.c1) return;
            container.innerHTML = '';

            charts.c1.data.datasets.forEach((ds, i) => {
                // Crear item
                const item = document.createElement('div');
                item.style.display = 'inline-flex';
                item.style.alignItems = 'center';
                item.style.gap = '6px';
                item.style.cursor = 'pointer';

                const sw = document.createElement('span');
                sw.style.display = 'inline-block';
                sw.style.width = '12px';
                sw.style.height = '12px';
                sw.style.borderRadius = '50%';
                sw.style.boxSizing = 'border-box';
                // color prefer backgroundColor then borderColor
                const color = (Array.isArray(ds.backgroundColor) ? ds.backgroundColor[0] : ds.backgroundColor) || ds.borderColor || '#666';
                sw.style.background = color;

                const label = document.createElement('span');
                label.textContent = ds.label || '';
                label.style.fontSize = '13px';
                label.style.color = '#374151';

                // Dim if hidden
                const hidden = !charts.c1.isDatasetVisible(i);
                if (hidden) {
                    sw.style.opacity = '0.4';
                    label.style.opacity = '0.4';
                }

                item.appendChild(sw);
                item.appendChild(label);

                item.addEventListener('click', () => {
                    const vis = charts.c1.isDatasetVisible(i);
                    charts.c1.setDatasetVisibility(i, !vis);
                    charts.c1.update();
                    renderChart1Legend();
                });

                container.appendChild(item);
            });
        }

        function initCharts() {
            // Función helper para dibujar texto con formato especial para la parte [$##]
            const drawFormattedText = (ctx, text, x, y, fontSize, isRight = false) => {
                const match = text.match(/^(.+?)\s*\[\$(.+?)\]$/);
                if (match) {
                    const mainPart = match[1];
                    const smallPart = '[$' + match[2] + ']';
                    
                    // Medir el texto principal (en negritas)
                    const mainMetrics = ctx.measureText(mainPart);
                    const mainWidth = mainMetrics.width;
                    
                    // Cambiar a fuente más pequeña y no negritas para la parte pequeña
                    const smallFontSize = fontSize - 1;
                    const currentFont = ctx.font;
                    ctx.font = smallFontSize + 'px ' + currentFont.split('px')[1];
                    
                    const smallMetrics = ctx.measureText(smallPart);
                    const smallWidth = smallMetrics.width;
                    
                    // Dibujar ambas partes
                    if (isRight) {
                        // Alineado a la derecha: pequeño + principal
                        ctx.fillText(smallPart, x - mainWidth - 2, y);
                        ctx.font = currentFont; // Restaurar font negritas
                        ctx.fillText(mainPart, x - smallWidth - 4, y);
                    } else {
                        // Alineado a la izquierda: principal + pequeño
                        ctx.font = currentFont; // Restaurar font negritas
                        ctx.fillText(mainPart, x, y);
                        ctx.font = smallFontSize + 'px ' + currentFont.split('px')[1];
                        ctx.fillText(smallPart, x + mainWidth + 2, y);
                    }
                    
                    ctx.font = currentFont; // Restaurar font original
                } else {
                    ctx.fillText(text, x, y);
                }
            };
            
            // Plugin para mostrar etiquetas en la base de las barras (3px entre eje X y dato)
            const barBaseLabelPlugin = {
                id: 'barBaseLabels',
                afterDatasetsDraw(chart, args, options) {
                    const ctx = chart.ctx;
                    const chartArea = chart.chartArea;

                    // ---------- BARRAS: etiquetas en la base (apiladas si hay varias series)
                    const barDatasetIndices = chart.data.datasets.map((d, i) => {
                        const m = chart.getDatasetMeta(i);
                        return (m && m.type === 'bar' && chart.isDatasetVisible(i)) ? i : -1;
                    }).filter(i => i >= 0);

                    const isHorizontalChart = chart.options && chart.options.indexAxis === 'y';

                    chart.data.datasets.forEach((dataset, datasetIndex) => {
                        const meta = chart.getDatasetMeta(datasetIndex);
                        // Solo para barras y visibles
                        if (!meta || meta.type !== 'bar' || !chart.isDatasetVisible(datasetIndex)) return;

                        const positionOffset = barDatasetIndices.indexOf(datasetIndex);
                        meta.data.forEach((bar, index) => {
                            const value = dataset.data[index];
                            if (value === null || value === undefined) return;

                            const x = bar.x;
                            const base = bar.base;

                            const padding = (options && options.padding) || 3;
                            const fontSize = (options && options.fontSize) || 14;
                            const fontFamily = (options && options.fontFamily) || 'Arial';
                            ctx.font = 'bold ' + fontSize + 'px ' + fontFamily;

                            let text = value;
                            if (typeof value === 'number') {
                                text = new Intl.NumberFormat('es-PE').format(value);
                                
                                // Agregar cálculo ×12 para gráficos de Saldos (chart5, chart2, chart3)
                                const chartId = chart && chart.canvas && chart.canvas.id;
                                const isSaldoChart = ['chart5', 'chart2', 'chart3'].includes(chartId);
                                const isSaldoDataset = dataset.label && dataset.label.toLowerCase().includes('saldos');
                                
                                if (isSaldoChart && isSaldoDataset) {
                                    const valueMultiplied = value * 12;
                                    const multipliedText = new Intl.NumberFormat('es-PE').format(valueMultiplied);
                                    text = text + 'pds [$' + multipliedText + ']';
                                }
                            }

                            const isIngresoNeto = dataset.label && dataset.label.toLowerCase().includes('ingreso');
                            const paddingX = 6;
                            const paddingY = 3;

                            const metrics = ctx.measureText(text);
                            const textWidth = metrics.width;
                            const rectWidth = textWidth + paddingX * 2;
                            const rectHeight = fontSize + paddingY * 2;

                            if (isHorizontalChart) {
                                // Para barras horizontales, 'base' es el inicio y 'x' es el extremo
                                const startX = Math.min(x, base);
                                const endX = Math.max(x, base);

                                // Por defecto colocamos la etiqueta cerca de la base (comportamiento de "Saldos 1ra").
                                // Evitamos forzar que chart2/chart3 estén a la derecha para que coincidan con chart5.
                                const desiredPadding = 1; // px entre barra y etiqueta
                                const labelX = startX + padding + 2;

                                // Si hay múltiples datasets de barra, desplazamos ligeramente en Y para evitar solapamiento
                                const stackSpacing = fontSize + 4;
                                const labelY = (bar.y || ((bar.top + bar.bottom) / 2)) + (positionOffset >= 0 ? positionOffset * stackSpacing : 0);

                                const rectX = labelX - paddingX;
                                const rectY = labelY - (rectHeight / 2);

                                // Evitar que la etiqueta quede fuera del area derecha: si se sale, moverla dentro (dentro de la barra)
                                let drawInside = false;
                                if (rectX + rectWidth > chartArea.right) {
                                    drawInside = true;
                                }

                                if (drawInside) {
                                    // Dibujar la etiqueta dentro de la barra (alineada a la derecha dentro de la barra)
                                    const insideX = endX - paddingX;
                                    if (isIngresoNeto) {
                                        const radius = 4;
                                        ctx.fillStyle = (options && options.bgColor) || '#F3F4F6';
                                        ctx.beginPath();
                                        ctx.moveTo(insideX - rectWidth + radius, rectY);
                                        ctx.arcTo(insideX + radius, rectY, insideX + radius, rectY + rectHeight, radius);
                                        ctx.arcTo(insideX + radius, rectY + rectHeight, insideX - rectWidth, rectY + rectHeight, radius);
                                        ctx.arcTo(insideX - rectWidth, rectY + rectHeight, insideX - rectWidth, rectY, radius);
                                        ctx.arcTo(insideX - rectWidth, rectY, insideX - rectWidth + radius, rectY, radius);
                                        ctx.closePath();
                                        ctx.fill();

                                        ctx.fillStyle = (options && options.color) || '#111827';
                                        ctx.textAlign = 'right';
                                        ctx.textBaseline = 'middle';
                                        drawFormattedText(ctx, text, insideX - 2, labelY, fontSize, true);
                                    } else {
                                        ctx.fillStyle = (options && options.color) || '#374151';
                                        ctx.textAlign = 'right';
                                        ctx.textBaseline = 'middle';
                                        drawFormattedText(ctx, text, insideX - 2, labelY, fontSize, true);
                                    }
                                } else {
                                    // Dibujar fuera a la derecha con 1px padding
                                    if (isIngresoNeto) {
                                        const radius = 4;
                                        ctx.fillStyle = (options && options.bgColor) || '#F3F4F6';
                                        ctx.beginPath();
                                        ctx.moveTo(rectX + radius, rectY);
                                        ctx.arcTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + rectHeight, radius);
                                        ctx.arcTo(rectX + rectWidth, rectY + rectHeight, rectX, rectY + rectHeight, radius);
                                        ctx.arcTo(rectX, rectY + rectHeight, rectX, rectY, radius);
                                        ctx.arcTo(rectX, rectY, rectX + rectWidth, rectY, radius);
                                        ctx.closePath();
                                        ctx.fill();

                                        ctx.fillStyle = (options && options.color) || '#111827';
                                        ctx.textAlign = 'left';
                                        ctx.textBaseline = 'middle';
                                        drawFormattedText(ctx, text, labelX, labelY, fontSize, false);
                                    } else {
                                        ctx.fillStyle = (options && options.color) || '#374151';
                                        ctx.textAlign = 'left';
                                        ctx.textBaseline = 'middle';
                                        drawFormattedText(ctx, text, labelX, labelY, fontSize, false);
                                    }
                                }
                            } else {
                                // Vertical bars (comportamiento previo): etiqueta encima de la base
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'bottom';

                                const stackSpacing = fontSize + 6;
                                const verticalOffset = (positionOffset >= 0) ? positionOffset * stackSpacing : 0;
                                const y = base - padding - verticalOffset;

                                const rectX = x - rectWidth / 2;
                                const rectY = y - fontSize - paddingY;

                                if (x >= chartArea.left && x <= chartArea.right && y >= chartArea.top && y <= chartArea.bottom) {
                                    if (isIngresoNeto) {
                                        const radius = 4;
                                        ctx.fillStyle = (options && options.bgColor) || '#F3F4F6';
                                        ctx.beginPath();
                                        ctx.moveTo(rectX + radius, rectY);
                                        ctx.arcTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + rectHeight, radius);
                                        ctx.arcTo(rectX + rectWidth, rectY + rectHeight, rectX, rectY + rectHeight, radius);
                                        ctx.arcTo(rectX, rectY + rectHeight, rectX, rectY, radius);
                                        ctx.arcTo(rectX, rectY, rectX + rectWidth, rectY, radius);
                                        ctx.closePath();
                                        ctx.fill();

                                        ctx.fillStyle = (options && options.color) || '#111827';
                                        drawFormattedText(ctx, text, x, y, fontSize, false);
                                    } else {
                                        ctx.fillStyle = (options && options.color) || '#374151';
                                        drawFormattedText(ctx, text, x, y, fontSize, false);
                                    }
                                }
                            }
                        });
                    });

                    // ---------- LINEAS: etiquetas encima de cada punto (negrita)
                    const lineDatasetIndices = chart.data.datasets.map((d, i) => {
                        const m = chart.getDatasetMeta(i);
                        return (m && m.type === 'line' && chart.isDatasetVisible(i)) ? i : -1;
                    }).filter(i => i >= 0);

                    chart.data.datasets.forEach((dataset, datasetIndex) => {
                        const meta = chart.getDatasetMeta(datasetIndex);
                        if (!meta || meta.type !== 'line' || !chart.isDatasetVisible(datasetIndex)) return;

                        // position among visible lines (for stacking if multiple)
                        const positionOffset = lineDatasetIndices.indexOf(datasetIndex);
                        const fontSize = (options && options.fontSize) || 12;
                        const fontFamily = (options && options.fontFamily) || 'Arial';
                        ctx.font = 'bold ' + fontSize + 'px ' + fontFamily;
                        // Mostrar etiquetas de línea. Por defecto a la derecha; para chart1 las colocamos arriba
                        meta.data.forEach((point, index) => {
                            if (!point || point.skip) return;
                            const x = point.x;
                            const yPoint = point.y;
                            const offset = (options && options.lineOffset) || 6;

                            let text = dataset.data[index];
                            if (typeof text === 'number') {
                                if (dataset.yAxisID === 'y1' || dataset.xAxisID === 'x1') {
                                    text = new Intl.NumberFormat('es-PE', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(text) + '%';
                                } else {
                                    text = new Intl.NumberFormat('es-PE').format(text);
                                }
                            }

                            // if multiple line datasets, stack upward (vertical shift)
                            const stackSpacing = fontSize + 4;
                            const isChart1 = chart && chart.canvas && (chart.canvas.id === 'chart1' || chart.canvas.id === 'chartClientes');

                            if (isChart1) {
                                // Etiqueta centrada arriba del punto
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'bottom';
                                const y = yPoint - offset - (positionOffset * stackSpacing);
                                const xLabel = x;
                                if (xLabel >= chartArea.left && xLabel <= chartArea.right && y >= chartArea.top && y <= chartArea.bottom) {
                                    ctx.fillStyle = (options && options.lineColor) || '#ef4444';
                                    drawFormattedText(ctx, text, xLabel, y, fontSize, false);
                                }
                            } else {
                                // Default: etiqueta a la derecha del punto
                                ctx.textAlign = 'left';
                                ctx.textBaseline = 'middle';
                                const y = yPoint - offset - (positionOffset * stackSpacing);
                                const horizOffset = (options && options.lineLabelOffsetX) ? options.lineLabelOffsetX : 8;
                                const xLabel = x + horizOffset + (positionOffset * 6);
                                if (xLabel >= chartArea.left && xLabel <= chartArea.right && y >= chartArea.top && y <= chartArea.bottom) {
                                    ctx.fillStyle = (options && options.lineColor) || '#111827';
                                    drawFormattedText(ctx, text, xLabel, y, fontSize, false);
                                }
                            }
                        });
                    });
                }
            };

            // Registrar plugin globalmente
            Chart.register(barBaseLabelPlugin);

            const commonOptions = {
                responsive: true,
                maintainAspectRatio: false,
                // Dejar espacio a la derecha para etiquetas dibujadas fuera del canvas
                layout: { padding: { right: 64 } },
                plugins: { 
                    legend: { 
                        position: 'bottom'
                    } 
                },
                scales: { y: { beginAtZero: true } }
            };

            // Chart 1: Mixto
            const ctx1 = document.getElementById('chart1').getContext('2d');
            charts.c1 = new Chart(ctx1, {
                type: 'bar',
                data: {
                    labels: [],
                        datasets: [
                        { label: 'Ingreso Neto', data: [], backgroundColor: '#3b82f6', order: 2, yAxisID: 'y' },
                        { label: 'Diferencia', data: [], backgroundColor: '#f97316', order: 2, yAxisID: 'y' },
                        { label: '% Dif', data: [], type: 'line', borderColor: '#ef4444', backgroundColor: '#ef4444', pointBackgroundColor: '#ef4444', pointBorderColor: '#ef4444', yAxisID: 'y1', order: 1 }
                    ]
                },
                options: {
                    ...commonOptions,
                    // Reducir padding derecho para que el chart ocupe más ancho
                    layout: { padding: { right: 16 } },
                        plugins: {
                            ...commonOptions.plugins,
                            // ocultar la leyenda nativa porque usamos una leyenda DOM a la derecha del título
                            legend: { display: false },
                            // Opciones para el plugin de etiquetas en la base de las barras
                            barBaseLabels: {
                                color: '#374151',
                                fontSize: 14,
                                fontFamily: 'Helvetica Neue, Arial',
                                padding: 1,
                                lineColor: '#ef4444',
                                lineOffset: 6
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) label += ': ';
                                        if (context.dataset.yAxisID === 'y1') {
                                            label += new Intl.NumberFormat('es-PE', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(context.parsed.y) + '%';
                                        } else {
                                            label += new Intl.NumberFormat('es-PE').format(context.parsed.y);
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                    scales: {
                        y: { 
                            position: 'left',
                            ticks: { callback: val => formatShortNumber(val) }
                        },
                        y1: { 
                            // Ocultamos el eje secundario para dar más espacio horizontal al chart
                            display: false,
                            grid: { display: false }
                        }
                    }
                }
            });

            // Chart 2: Saldos 2da (Horizontal bar + line), similar to chart5
            const ctx2 = document.getElementById('chart2').getContext('2d');
            charts.c2 = new Chart(ctx2, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                            { label: 'Saldos 2da', data: [], backgroundColor: '#fdba74', borderRadius: 3, yAxisID: 'y' },
                            { label: '%Saldos 2da', data: [], type: 'line', borderColor: '#fdba74', backgroundColor: '#fdba74', pointBackgroundColor: '#fdba74', pointBorderColor: '#fdba74', xAxisID: 'x1', order: 0 }
                        ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: { right: 48 } },
                    // Ajustes del plugin de etiquetas en base de barras
                    plugins: {
                        barBaseLabels: { fontSize: 14, color: '#374151', fontFamily: 'Helvetica Neue, Arial', padding: 3 }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    // Para charts horizontales las líneas usan x1 como eje secundario
                                    if (context.dataset.xAxisID === 'x1') {
                                        label += new Intl.NumberFormat('es-PE', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(context.parsed.x) + '%';
                                    } else {
                                        label += new Intl.NumberFormat('es-PE').format(context.parsed.x);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: { beginAtZero: true, display: true, ticks: { color: '#374151' }, grid: { color: '#e6e6e6' } },
                        x: {
                            beginAtZero: true,
                            min: 0,
                            max: 20000,
                            ticks: { callback: val => formatShortNumber(val), color: '#374151', stepSize: 5000, font: { weight: 'bold' } },
                            grid: { color: '#e6e6e6' }
                        },
                        x1: {
                            position: 'top',
                            display: false,
                            min: -5,
                            grid: { display: false }
                        }
                    }
                }
            });

            // Chart 3: Saldos 3ra (Horizontal bar + line)
            const ctx3 = document.getElementById('chart3').getContext('2d');
            charts.c3 = new Chart(ctx3, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'Saldos 3ra', data: [], backgroundColor: '#fecaca', borderRadius: 3, yAxisID: 'y' },
                        { label: '%Saldos 3ra', data: [], type: 'line', borderColor: '#fecaca', backgroundColor: '#fecaca', pointBackgroundColor: '#fecaca', pointBorderColor: '#fecaca', xAxisID: 'x1', order: 0 }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: { right: 48 } },
                    plugins: {
                        barBaseLabels: { fontSize: 14, color: '#374151', fontFamily: 'Helvetica Neue, Arial', padding: 3 }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.dataset.xAxisID === 'x1') {
                                        label += new Intl.NumberFormat('es-PE', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(context.parsed.x) + '%';
                                    } else {
                                        label += new Intl.NumberFormat('es-PE').format(context.parsed.x);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: { beginAtZero: true, display: true, ticks: { color: '#374151' }, grid: { color: '#e6e6e6' } },
                        x: {
                            beginAtZero: true,
                            min: 0,
                            max: 20000,
                            ticks: { callback: val => formatShortNumber(val), color: '#374151', stepSize: 5000, font: { weight: 'bold' } },
                            grid: { color: '#e6e6e6' }
                        },
                        x1: {
                            position: 'top',
                            display: false,
                            grid: { display: false }
                        }
                    }
                }
            });

            // Chart Clientes: Análisis por Cliente (barras + línea)
            const ctxClientes = document.getElementById('chartClientes').getContext('2d');
            charts.clientes = new Chart(ctxClientes, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'Prendas Ingreso Neto', data: [], backgroundColor: '#7dd3fc', yAxisID: 'y', order: 2 },
                        { label: '%Saldo 1ra', data: [], type: 'line', borderColor: '#ef4444', backgroundColor: '#ef4444', pointBackgroundColor: '#ef4444', yAxisID: 'y1', order: 1 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: { right: 8 } },
                    plugins: {
                        legend: { position: 'bottom' },
                        barBaseLabels: {
                            color: '#374151',
                            fontSize: 16,
                            fontFamily: 'Helvetica Neue, Arial',
                            padding: 3,
                            lineColor: '#ef4444',
                            lineOffset: 10
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.dataset.yAxisID === 'y1') {
                                        label += new Intl.NumberFormat('es-PE', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(context.parsed.y) + '%';
                                    } else {
                                        label += new Intl.NumberFormat('es-PE').format(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            position: 'left',
                            beginAtZero: true,
                            ticks: { callback: val => formatShortNumber(val) }
                        },
                        y1: {
                            position: 'right',
                            display: false,
                            beginAtZero: true,
                            min: -5,
                            grid: { display: false },
                            ticks: {
                                callback: function(val) {
                                    return val.toFixed(2) + '%';
                                }
                            }
                        }
                    }
                }
            });

            // Chart 5: Saldos 1ra (Horizontal bar + line)
            const ctx5 = document.getElementById('chart5').getContext('2d');
            charts.c5 = new Chart(ctx5, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'Saldos 1ra', data: [], backgroundColor: '#93c5fd', borderRadius: 3, yAxisID: 'y' },
                        { label: '%Saldos 1ra', data: [], type: 'line', borderColor: '#93c5fd', backgroundColor: '#93c5fd', pointBackgroundColor: '#93c5fd', pointBorderColor: '#93c5fd', xAxisID: 'x1', order: 0 }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: { right: 48 } },
                    plugins: {
                        barBaseLabels: { fontSize: 14, color: '#374151', fontFamily: 'Helvetica Neue, Arial', padding: 3 }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.dataset.xAxisID === 'x1') {
                                        label += new Intl.NumberFormat('es-PE', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(context.parsed.x) + '%';
                                    } else {
                                        label += new Intl.NumberFormat('es-PE').format(context.parsed.x);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        // Mostrar eje Y con etiquetas de categoría (meses)
                        y: { display: true, ticks: { color: '#374151' } },
                        x: { beginAtZero: true, min:0, max:20000, ticks: { callback: val => formatShortNumber(val), color: '#374151', stepSize: 5000, font: { weight: 'bold' } }, grid: { color: '#e6e6e6' } },
                        x1: { position: 'top', display: false, min: -7, grid: { display: false } }
                    }
                }
            });
        }

        async function actualizarGraficos(silentMode = false) {
            const loading = document.getElementById('mainLoader');
            if (!silentMode) {
                loading.classList.remove('hidden');
                setConnectionStatus('loading', 'Actualizando...');
            }

            // Actualizar título del gráfico 1 según filtros seleccionados
            try { actualizarTituloChart1(); actualizarTituloEvolucion(); } catch(e) { console.warn('Error actualizando títulos', e); }

            const params = {
                action: 'getDashboardData',
                desdeAnio: document.getElementById('desdeAnio').value,
                desdeMes: document.getElementById('desdeMes').value,
                hastaAnio: document.getElementById('hastaAnio').value,
                hastaMes: document.getElementById('hastaMes').value
            };
            
            // Verificar si tenemos datos en caché válidos
            const paramsKey = JSON.stringify(params);
            const now = Date.now();
            if (cache.dashboard && cache.lastParams === paramsKey && 
                cache.timestamp && (now - cache.timestamp) < cache.TTL) {
                // Usar caché
                procesarDatos(cache.dashboard);
                if (!silentMode) {
                    loading.classList.add('hidden');
                    setConnectionStatus('success', 'Datos en caché');
                    setTimeout(() => setConnectionStatus('success', 'Conectado'), 2000);
                }
                return;
            }

            try {
                // LLAMADA AL GOOGLE SHEET REAL con timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 segundos timeout
                
                const response = await fetch(SCRIPT_URL, {
                    method: 'POST',
                    redirect: "follow", 
                    credentials: 'omit',
                    signal: controller.signal,
                    body: JSON.stringify(params)
                });
                
                clearTimeout(timeoutId);
                const result = await response.json();
                
                if (result.status === 'success') {
                    // Guardar en caché
                    cache.dashboard = result.data;
                    cache.lastParams = paramsKey;
                    cache.timestamp = now;
                    
                    procesarDatos(result.data);
                    setConnectionStatus('success', 'Conectado');
                } else {
                    console.error("Error del servidor:", result.message);
                    setConnectionStatus('error', 'Error del servidor');
                    alert("Error al cargar datos: " + result.message);
                }

            } catch (error) {
                setConnectionStatus('error', 'Error de conexión');
                if (error.name === 'AbortError') {
                    alert("La solicitud tardó demasiado. Por favor, intenta de nuevo.");
                } else {
                    console.error("Error de conexión:", error);
                    // Mensaje amigable para entorno local
                    let msg = "Error de conexión. ";
                    if(window.location.protocol === 'file:') msg += "Asegúrate de tener conexión a internet.";
                    else msg += "Si estás en vista previa, descarga el HTML.";
                    alert(msg);
                }
            } finally {
                if (!silentMode) loading.classList.add('hidden');
            }
        }

        function procesarDatos(data) {
            if (!data || data.length === 0) {
                // Limpiar gráficos
                [charts.c1, charts.c2, charts.c5, charts.c3].forEach(c => {
                    if (c) {
                        c.data.labels = [];
                        c.data.datasets.forEach(d => d.data = []);
                    }
                });
                return;
            }

            // Preparar arrays
            const labels = [];
            const dataIngreso = [];
            const dataDiferencia = [];
            const dataPorcentaje = [];
            const dataSaldos1ra = [];
            const dataPorcSaldos1ra = [];
            const dataSaldos2da = [];
            const dataPorcSaldos2da = [];
            const dataSaldos3ra = [];
            const dataPorcSaldos3ra = [];

            // Procesar datos una sola vez
            data.forEach(item => {
                labels.push(`${item.mes} ${item.anio}`);
                
                const ing = parseFloat(item.ingreso) || 0;
                const dif = parseFloat(item.diferencia) || 0;
                const saldos1ra = parseFloat(item.saldos1ra) || 0;
                const saldos2da = parseFloat(item.saldos2da) || 0;
                const saldos3ra = parseFloat(item.saldos3ra) || 0;
                const porc = (parseFloat(item.porcentaje) || 0) * 100;
                
                dataIngreso.push(ing);
                dataDiferencia.push(dif);
                dataSaldos1ra.push(saldos1ra);
                dataSaldos2da.push(saldos2da);
                dataSaldos3ra.push(saldos3ra);
                dataPorcentaje.push(Number(porc.toFixed(2)));

                // Cálculos de porcentajes
                dataPorcSaldos1ra.push(ing !== 0 ? Number(((saldos1ra / ing) * 100).toFixed(2)) : 0);
                dataPorcSaldos2da.push(ing !== 0 ? Number(((saldos2da / ing) * 100).toFixed(2)) : 0);
                dataPorcSaldos3ra.push(ing !== 0 ? Number(((saldos3ra / ing) * 100).toFixed(2)) : 0);
            });

            // Actualizar todos los gráficos en batch
            requestAnimationFrame(() => {
                // Gráfico 1
                charts.c1.data.labels = labels;
                charts.c1.data.datasets[0].data = dataIngreso;
                charts.c1.data.datasets[1].data = dataDiferencia;
                charts.c1.data.datasets[2].data = dataPorcentaje;
                ajustarEjeY1(charts.c1, dataPorcentaje, -0.3);

                // Gráfico 2
                charts.c2.data.labels = labels;
                charts.c2.data.datasets[0].data = dataSaldos2da;
                charts.c2.data.datasets[1].data = dataPorcSaldos2da;
                ajustarEjeX1(charts.c2, dataPorcSaldos2da, -0.3);

                // Gráfico 3
                if (charts.c3) {
                    charts.c3.data.labels = labels;
                    charts.c3.data.datasets[0].data = dataSaldos3ra;
                    charts.c3.data.datasets[1].data = dataPorcSaldos3ra;
                    ajustarEjeX1(charts.c3, dataPorcSaldos3ra, -5);
                }

                // Gráfico 5
                charts.c5.data.labels = labels;
                charts.c5.data.datasets[0].data = dataSaldos1ra;
                charts.c5.data.datasets[1].data = dataPorcSaldos1ra;
                ajustarEjeX1(charts.c5, dataPorcSaldos1ra, -7);

                // Actualizar todos los gráficos una sola vez
                charts.c1.update('none'); // 'none' evita animaciones para mayor velocidad
                charts.c2.update('none');
                if (charts.c3) charts.c3.update('none');
                charts.c5.update('none');
                
                // Actualizar leyenda
                try { renderChart1Legend(); } catch(e) { console.warn('Error renderizando leyenda', e); }
            });
        }
        
        // Helper para ajustar eje Y secundario
        function ajustarEjeY1(chart, data, minVal) {
            try {
                const maxPorc = data.length ? Math.max(...data.map(v => Number(v) || 0)) : 0;
                const suggestedMax = maxPorc > 0 ? maxPorc * 1.25 : 1;
                if (!chart.options.scales.y1) chart.options.scales.y1 = {};
                chart.options.scales.y1.max = Math.round(suggestedMax * 100) / 100;
                chart.options.scales.y1.min = minVal;
            } catch (e) {
                console.warn('Error ajustando eje y1', e);
            }
        }
        
        // Helper para ajustar eje X secundario (gráficos horizontales)
        function ajustarEjeX1(chart, data, minVal) {
            try {
                const maxPorc = data.length ? Math.max(...data.map(v => Number(v) || 0)) : 0;
                const suggestedMax = maxPorc > 0 ? maxPorc * 1.25 : 1;
                if (!chart.options.scales.x1) chart.options.scales.x1 = {};
                chart.options.scales.x1.max = Math.round(suggestedMax * 100) / 100;
                chart.options.scales.x1.min = minVal;
                if (!chart.options.scales.x) chart.options.scales.x = {};
                chart.options.scales.x.max = 20000;
                chart.options.scales.x.min = 0;
            } catch (e) {
                console.warn('Error ajustando eje x1', e);
            }
        }

        async function cargarDatosClientes() {
            // Verificar si tenemos datos en caché válidos
            const now = Date.now();
            if (cache.clientes && cache.timestamp && (now - cache.timestamp) < cache.TTL) {
                actualizarTablaClientes(cache.clientes);
                actualizarGraficoClientes(cache.clientes);
                return;
            }
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 15000);
                
                const response = await fetch(SCRIPT_URL, {
                    method: 'POST',
                    redirect: "follow",
                    credentials: 'omit',
                    signal: controller.signal,
                    body: JSON.stringify({ action: 'getClienteData' })
                });
                
                clearTimeout(timeoutId);
                const result = await response.json();
                
                if (result.status === 'success' && result.data) {
                    // Ordenar por %Saldo 1ra descendente antes de renderizar
                    result.data.sort((a,b) => (b.porcentajeSaldo1ra || 0) - (a.porcentajeSaldo1ra || 0));
                    
                    // Guardar en caché
                    cache.clientes = result.data;
                    if (!cache.timestamp) cache.timestamp = now;
                    
                    actualizarTablaClientes(result.data);
                    actualizarGraficoClientes(result.data);
                } else {
                    console.error("Error al cargar datos de clientes:", result.message);
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.warn("Timeout al cargar datos de clientes");
                } else {
                    console.error("Error de conexión al cargar datos de clientes:", error);
                }
            }
        }

        function actualizarTablaClientes(data) {
            const tbody = document.getElementById('tablaClientesBody');
            const periodo = document.getElementById('clientePeriodo');
            
            if (!data || data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="py-2 text-center text-gray-400">No hay datos disponibles</td></tr>';
                periodo.textContent = '';
                return;
            }

            // Mostrar periodo en el encabezado
            if (data[0].anio && data[0].mes) {
                periodo.textContent = `${data[0].mes} ${data[0].anio}`;
            }

            // Calcular totales
            const totals = data.reduce((acc, row) => {
                acc.prendasPedido += Number(row.prendasPedido) || 0;
                acc.prendasIngresoNeto += Number(row.prendasIngresoNeto) || 0;
                acc.saldos1ra += Number(row.saldos1ra) || 0;
                return acc;
            }, { prendasPedido: 0, prendasIngresoNeto: 0, saldos1ra: 0 });

            const totalPorc = totals.prendasIngresoNeto ? (totals.saldos1ra / totals.prendasIngresoNeto) * 100 : 0;

            // Generar filas usando DocumentFragment para mejor rendimiento
            const fragment = document.createDocumentFragment();
            const formatter = new Intl.NumberFormat('es-PE');
            
            data.forEach(row => {
                const tr = document.createElement('tr');
                tr.className = 'border-b hover:bg-gray-50';
                const porcSaldo = row.porcentajeSaldo1ra || 0;
                
                tr.innerHTML = `
                    <td class="py-2 px-2">${row.cliente || ''}</td>
                    <td class="py-2 px-2">${row.tipoOp || ''}</td>
                    <td class="py-2 px-2 text-right">${formatter.format(row.prendasPedido || 0)}</td>
                    <td class="py-2 px-2 text-right">${formatter.format(row.prendasIngresoNeto || 0)}</td>
                    <td class="py-2 px-2 text-right">${formatter.format(row.saldos1ra || 0)}</td>
                    <td class="py-2 px-2 text-right font-semibold">${porcSaldo.toFixed(2)}%</td>
                `;
                fragment.appendChild(tr);
            });

            // Fila total
            const totalTr = document.createElement('tr');
            totalTr.className = 'bg-gray-800 text-white font-bold';
            totalTr.innerHTML = `
                <td class="py-2 px-2">TOTAL</td>
                <td class="py-2 px-2">&nbsp;</td>
                <td class="py-2 px-2 text-right">${formatter.format(totals.prendasPedido)}</td>
                <td class="py-2 px-2 text-right">${formatter.format(totals.prendasIngresoNeto)}</td>
                <td class="py-2 px-2 text-right">${formatter.format(totals.saldos1ra)}</td>
                <td class="py-2 px-2 text-right">${totalPorc.toFixed(2)}%</td>
            `;
            fragment.appendChild(totalTr);

            // Actualizar DOM una sola vez
            tbody.innerHTML = '';
            tbody.appendChild(fragment);
        }

        function actualizarGraficoClientes(data) {
            if (!charts.clientes || !data || data.length === 0) return;

            // Agrupar por cliente (sumar prendasIngresoNeto y saldos1ra)
            const map = {};
            data.forEach(row => {
                const cliente = (row.cliente || '').toString();
                if (!map[cliente]) map[cliente] = { cliente: cliente, prendasIngresoNeto: 0, saldos1ra: 0 };
                map[cliente].prendasIngresoNeto += Number(row.prendasIngresoNeto) || 0;
                map[cliente].saldos1ra += Number(row.saldos1ra) || 0;
            });

            const aggregated = Object.values(map);
            // Calcular %Saldo1ra agregado por cliente
            aggregated.forEach(r => {
                r.porc = r.prendasIngresoNeto ? (r.saldos1ra / r.prendasIngresoNeto) * 100 : 0;
            });
            // Ordenar por %Saldo1ra descendente
            aggregated.sort((a, b) => b.porc - a.porc);

            const labels = aggregated.map(r => r.cliente || '');
            const prendasIngreso = aggregated.map(r => r.prendasIngresoNeto || 0);
            const porcSaldos = aggregated.map(r => r.porc || 0);

            // Actualizar en batch usando requestAnimationFrame
            requestAnimationFrame(() => {
                charts.clientes.data.labels = labels;
                charts.clientes.data.datasets[0].data = prendasIngreso;
                charts.clientes.data.datasets[1].data = porcSaldos;

                // Ajustar máximo del eje secundario
                try {
                    const maxPorc = porcSaldos.length ? Math.max(...porcSaldos.map(v => Number(v) || 0)) : 0;
                    const suggestedMax = maxPorc > 0 ? maxPorc * 1.25 : 1;
                    if (!charts.clientes.options.scales.y1) charts.clientes.options.scales.y1 = {};
                    charts.clientes.options.scales.y1.max = Math.round(suggestedMax * 100) / 100;
                    charts.clientes.options.scales.y1.min = -5;
                } catch (e) {
                    console.warn('No se pudo ajustar max del eje y1 en chartClientes', e);
                }

                charts.clientes.update('none');
            });
        }

            // Función auxiliar para crear el botón +
            function crearBotonAgregar(columns) {
                const info = document.getElementById('accionesFilterInfo');
                if (info) {
                    info.innerHTML = '';
                    const btn = document.createElement('button');
                    btn.id = 'btnAgregarAccion';
                    btn.title = 'Agregar acción';
                    btn.className = 'inline-flex items-center justify-center h-8 w-8 bg-blue-600 hover:bg-blue-700 text-white rounded shadow';
                    btn.innerText = '+';
                    btn.addEventListener('click', () => agregarFilaEditable(columns));
                    info.appendChild(btn);
                }
            }

            // Cargar acciones desde la hoja 'acciones' via SCRIPT_URL y filtrar por columna 'Pestaña'
            async function cargarAcciones() {
                const tbody = document.getElementById('tablaAccionesBody');
                const thead = document.getElementById('tablaAccionesHead');
                const info = document.getElementById('accionesFilterInfo');
                if (tbody) tbody.innerHTML = '<tr><td colspan="4" class="py-2 text-center text-gray-400">Cargando...</td></tr>';
                if (thead) thead.innerHTML = '';
                if (info) info.textContent = '';

                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000);

                    const response = await fetch(SCRIPT_URL, {
                        method: 'POST',
                        redirect: 'follow',
                        credentials: 'omit',
                        signal: controller.signal,
                        body: JSON.stringify({ action: 'getAcciones' })
                    });

                    clearTimeout(timeoutId);
                    const result = await response.json();
                    if (!(result && result.status === 'success' && Array.isArray(result.data))) {
                        if (tbody) tbody.innerHTML = '<tr><td colspan="4" class="py-2 text-center text-gray-400">No hay datos de acciones</td></tr>';
                        // Crear botón + con columnas por defecto
                        const defaultColumns = ['Pestaña', 'Problema', 'Acciones', 'Responsable', 'Fecha Fin'];
                        crearBotonAgregar(defaultColumns);
                        return;
                    }

                    const allRows = result.data;
                    if (!allRows || allRows.length === 0) {
                        if (tbody) tbody.innerHTML = '<tr><td colspan="4" class="py-2 text-center text-gray-400">No hay datos de acciones</td></tr>';
                        // Crear botón + con columnas por defecto
                        const defaultColumns = ['Pestaña', 'Problema', 'Acciones', 'Responsable', 'Fecha Fin'];
                        crearBotonAgregar(defaultColumns);
                        return;
                    }

                    // Detectar la clave de la columna que contiene 'pesta' (p. ej. 'Pestaña')
                    const sample = allRows[0] || {};
                    const pestaKey = Object.keys(sample).find(k => k && k.toLowerCase().includes('pesta')) || 'Pestaña';
                    const activeBtn = document.querySelector('.tab-button.active');
                    const currentTabName = activeBtn ? activeBtn.innerText.trim() : 'Pds por regularizar';

                    const filtered = allRows.filter(r => {
                        const val = r[pestaKey];
                        return String(val || '').trim().toLowerCase() === currentTabName.toLowerCase();
                    });

                    // Mostrar info de filtro
                    // Reemplazar texto por botón '+' para agregar filas editables
                    const columns = Object.keys(sample || {});
                    crearBotonAgregar(columns);

                    // Renderizar tabla con columnas en orden del primer objeto
                    renderTablaAcciones(filtered, columns);
                } catch (err) {
                    console.error('Error cargando acciones:', err);
                    const tbody = document.getElementById('tablaAccionesBody');
                    if (tbody) tbody.innerHTML = '<tr><td colspan="4" class="py-2 text-center text-gray-400">Error al cargar acciones</td></tr>';
                    // Crear botón + con columnas por defecto
                    const defaultColumns = ['Pestaña', 'Problema', 'Acciones', 'Responsable', 'Fecha Fin'];
                    crearBotonAgregar(defaultColumns);
                }
            }

            function renderTablaAcciones(rows, columns) {
                const thead = document.getElementById('tablaAccionesHead');
                const tbody = document.getElementById('tablaAccionesBody');
                if (!thead || !tbody) return;

                // Construir header y body
                const pestaIdxLocal = columns.findIndex(c => c && c.toLowerCase().includes('pesta'));
                const visibleColumns = columns.filter((c, idx) => idx !== pestaIdxLocal);

                // calcular anchos fijos por columna visible (una sola vez)
                const widthMap = { 'problema': 20, 'accion': 60, 'respons': 10, 'fecha': 10 };
                const assignedVisible = visibleColumns.map(c => {
                    const k = (c || '').toString().toLowerCase();
                    for (const key in widthMap) {
                        if (k.includes(key)) return widthMap[key];
                    }
                    return 0;
                });
                
                let ssum = assignedVisible.reduce((a,b)=>a+b,0);
                if (ssum === 0) {
                    const eq = Math.floor(100 / visibleColumns.length);
                    assignedVisible.fill(eq);
                    assignedVisible[assignedVisible.length-1] += 100 - eq * visibleColumns.length;
                } else if (ssum !== 100) {
                    const factor = 100 / ssum;
                    for (let i=0; i<assignedVisible.length; i++) {
                        assignedVisible[i] = Math.round(assignedVisible[i]*factor);
                    }
                    let s2 = assignedVisible.reduce((a,b)=>a+b,0);
                    if (s2 !== 100) assignedVisible[assignedVisible.length-1] += 100 - s2;
                }

                // header con innerHTML para mayor velocidad
                const headerHTML = visibleColumns.map((col, i) => 
                    `<th class="py-2 px-2 border-b text-left text-xs font-bold text-white" style="width:${assignedVisible[i]}%">${col}</th>`
                ).join('');
                thead.innerHTML = `<tr>${headerHTML}</tr>`;

                // body
                if (!rows || rows.length === 0) {
                    tbody.innerHTML = `<tr><td colspan="${visibleColumns.length}" class="py-2 text-center text-gray-400">No hay acciones</td></tr>`;
                    return;
                }

                // Caché de meses para evitar crear el array repetidamente
                const months = ['ene','feb','mar','abr','may','jun','jul','ago','set','oct','nov','dic'];
                
                // Función optimizada para formatear fechas
                const formatValue = (v) => {
                    if (v === null || v === undefined || v === '') return '';
                    
                    // Intentar parsear fecha solo si parece una fecha
                    if (typeof v === 'string' && (v.includes('T') || v.includes('-') || v.includes('/'))) {
                        const parsed = new Date(v);
                        if (!isNaN(parsed.getTime())) {
                            return `${String(parsed.getDate()).padStart(2,'0')}/${months[parsed.getMonth()]}/${parsed.getFullYear()}`;
                        }
                    } else if (v instanceof Date && !isNaN(v.getTime())) {
                        return `${String(v.getDate()).padStart(2,'0')}/${months[v.getMonth()]}/${v.getFullYear()}`;
                    }
                    return String(v);
                };

                // Construir todo el HTML de una vez (mucho más rápido que createElement)
                const rowsHTML = rows.map(r => {
                    const cellsHTML = visibleColumns.map((col, i) => 
                        `<td class="py-2 px-2" style="width:${assignedVisible[i]}%">${formatValue(r[col])}</td>`
                    ).join('');
                    return `<tr class="border-b">${cellsHTML}</tr>`;
                }).join('');
                
                tbody.innerHTML = rowsHTML;

                // ocultar info de anchos
                const infoEl = document.getElementById('accionesColWidths');
                if (infoEl) infoEl.innerHTML = '';
            }

            // Renderizar solo los encabezados de la tabla
            function renderHeadersAcciones(columns) {
                const thead = document.getElementById('tablaAccionesHead');
                if (!thead) return;

                const pestaIdxLocal = columns.findIndex(c => c && c.toLowerCase().includes('pesta'));
                const visibleColumns = columns.filter((c, idx) => idx !== pestaIdxLocal);

                // calcular anchos fijos por columna visible
                const widthMap = { 'problema': 20, 'accion': 60, 'respons': 10, 'fecha': 10 };
                const assignedVisible = visibleColumns.map(c => {
                    const k = (c || '').toString().toLowerCase();
                    for (const key in widthMap) {
                        if (k.includes(key)) return widthMap[key];
                    }
                    return 0;
                });
                
                let ssum = assignedVisible.reduce((a,b)=>a+b,0);
                if (ssum === 0) {
                    const eq = Math.floor(100 / visibleColumns.length);
                    assignedVisible.fill(eq);
                    assignedVisible[assignedVisible.length-1] += 100 - eq * visibleColumns.length;
                } else if (ssum !== 100) {
                    const factor = 100 / ssum;
                    for (let i=0; i<assignedVisible.length; i++) {
                        assignedVisible[i] = Math.round(assignedVisible[i]*factor);
                    }
                    let s2 = assignedVisible.reduce((a,b)=>a+b,0);
                    if (s2 !== 100) assignedVisible[assignedVisible.length-1] += 100 - s2;
                }

                // header con innerHTML para mayor velocidad
                const headerHTML = visibleColumns.map((col, i) => 
                    `<th class="py-2 px-2 border-b text-left text-xs font-bold text-white" style="width:${assignedVisible[i]}%">${col}</th>`
                ).join('');
                thead.innerHTML = `<tr>${headerHTML}</tr>`;
            }

            // Inserta una fila editable en la tabla de Acciones (al final)
            function agregarFilaEditable(columns) {
                const tbody = document.getElementById('tablaAccionesBody');
                const thead = document.getElementById('tablaAccionesHead');
                if (!tbody) return;

                // Si no hay headers, renderizarlos primero
                if (thead && !thead.innerHTML.trim()) {
                    renderHeadersAcciones(columns);
                }

                // Limpiar el mensaje "No hay datos" si existe
                const noDataRow = tbody.querySelector('tr td[colspan]');
                if (noDataRow) {
                    tbody.innerHTML = '';
                }

                // Si ya hay una fila editable, enfocar la primera celda
                const existing = tbody.querySelector('tr[data-editable="1"]');
                if (existing) {
                    const c = existing.querySelector('td[contenteditable]'); if (c) c.focus();
                    return;
                }

                const tr = document.createElement('tr');
                tr.className = 'border-b bg-yellow-50';
                tr.setAttribute('data-editable', '1');

                // Determinar nombre de pestaña activa
                function getActiveTabName() {
                    const btn = document.querySelector('.tab-button.active');
                    return btn ? btn.innerText.trim() : 'Pds por regularizar';
                }
                const activeTab = getActiveTabName();

                // localizar índice de columna 'pesta' (si existe) y 'fecha fin'
                const pestaIdx = columns.findIndex(c => c && c.toLowerCase().includes('pesta'));
                let fechaIdx = columns.findIndex(c => c && c.toLowerCase().includes('fecha') && c.toLowerCase().includes('fin'));
                if (fechaIdx === -1) fechaIdx = columns.findIndex(c => c && c.toLowerCase().includes('fecha'));

                columns.forEach((col, idx) => {
                    // No crear celda visual para la columna 'Pestaña' (se autocompleta al guardar)
                    if (idx === pestaIdx) return;

                    const td = document.createElement('td');
                    td.className = 'py-2 px-2';
                    td.dataset.col = col;
                    td.dataset.index = idx;

                    if (idx === fechaIdx) {
                        // Fecha Fin: mostrar input type=date prellenado con hoy
                        const input = document.createElement('input');
                        input.type = 'date';
                        input.className = 'w-full text-sm p-1 border rounded';
                        const hoy = new Date();
                        const yyyy = hoy.getFullYear();
                        const mm = String(hoy.getMonth() + 1).padStart(2,'0');
                        const dd = String(hoy.getDate()).padStart(2,'0');
                        input.value = yyyy + '-' + mm + '-' + dd;
                        // No autoguardar: el usuario debe presionar Guardar
                        td.appendChild(input);
                    } else {
                        td.contentEditable = 'true';
                        td.spellcheck = false;
                        td.addEventListener('keydown', function(e) {
                            if (e.key === 'Enter') { e.preventDefault(); this.blur(); }
                        });
                        // No autoguardar en blur: guardar se realiza con el botón Guardar
                    }
                    tr.appendChild(td);
                });

                // Insertar al final (debajo de todas las filas)
                tbody.appendChild(tr);

                // Foco en la primera editable celda (si existe)
                const firstEditable = tr.querySelector('td[contenteditable="true"]'); if (firstEditable) firstEditable.focus();

                // Añadir botones Guardar / Cancelar para controlar el guardado manual
                addSaveCancelButtons(tr, columns);
            }

            async function attemptSaveAccion(tr, columns) {
                if (!tr || tr.getAttribute('data-editable') !== '1') return;
                if (isSavingAccion) return; // evitar envíos concurrentes
                isSavingAccion = true;
                const btnG = document.getElementById('btnGuardarAccion');
                const btnC = document.getElementById('btnCancelarAccion');
                if (btnG) btnG.disabled = true;
                if (btnC) btnC.disabled = true;
                const cells = Array.from(tr.querySelectorAll('td'));
                const obj = {};
                let anyValue = false;
                cells.forEach(td => {
                    const key = td.dataset.col || '';
                    // Si contiene un input[type=date], tomar su valor y convertir a ISO
                    const inputDate = td.querySelector('input[type="date"]');
                    let val = '';
                    if (inputDate) {
                        const v = inputDate.value || '';
                        if (v) {
                            // convertir YYYY-MM-DD a ISO
                            try {
                                const dt = new Date(v + 'T00:00:00');
                                val = dt.toISOString();
                            } catch (e) {
                                val = v;
                            }
                        } else {
                            val = '';
                        }
                    } else {
                        val = (td.textContent || '').trim();
                    }
                    if (val !== '') anyValue = true;
                    obj[key] = val;
                });

                if (!anyValue) {
                    // eliminar fila vacía
                    tr.remove();
                    return;
                }

                // Asegurar que la columna 'Pestaña' tenga el valor de la pestaña activa
                let pestaKey = Object.keys(obj).find(k => k && k.toLowerCase().includes('pesta'));
                if (!pestaKey) {
                    // Si no está en obj (no se creó la celda), buscar en la lista de columnas
                    pestaKey = (columns || []).find(c => c && c.toLowerCase().includes('pesta'));
                }
                if (pestaKey) {
                    const btn = document.querySelector('.tab-button.active');
                    const activeTabName = btn ? btn.innerText.trim() : 'Pds por regularizar';
                    obj[pestaKey] = activeTabName;
                }

                // Mostrar estado
                tr.style.opacity = '0.6';
                try {
                    const saved = await saveAccion(obj);
                    tr.style.opacity = '1';
                    if (saved) {
                        // refrescar tabla completa para mantener consistencia
                        removeSaveCancelButtons();
                        cargarAcciones();
                    } else {
                        // Indicar error visualmente
                        tr.style.backgroundColor = '#fee2e2';
                        if (btnG) btnG.disabled = false;
                        if (btnC) btnC.disabled = false;
                    }
                } finally {
                    isSavingAccion = false;
                    if (btnG) btnG.disabled = false;
                    if (btnC) btnC.disabled = false;
                }
            }

            // Enviar nueva acción al servidor
            async function saveAccion(data) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000);

                    const response = await fetch(SCRIPT_URL, {
                        method: 'POST',
                        redirect: 'follow',
                        credentials: 'omit',
                        signal: controller.signal,
                        body: JSON.stringify({ action: 'saveAccion', data: data })
                    });

                    clearTimeout(timeoutId);
                    const result = await response.json();
                    if (result && result.status === 'success') return true;
                    console.error('Error guardando accion:', result && result.message);
                    return false;
                } catch (err) {
                    console.error('Error guardando accion:', err);
                    return false;
                }
            }
    </script>
</body>
</html>
